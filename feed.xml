<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>gorpeln的个人博客 - gorpeln</title>
    <link>https://gorpeln.top</link>
    <description>gorpeln的个人博客（https://gorpeln.top/）是一个为记录生活里的点滴、分享技术成长、资源共享的个人优秀博客！趁年轻，做自己想做的！</description>
    
      <item>
        <title>定期自动备份又拍云存储</title>
        <link>https://gorpeln.top/article/17280983368</link>
        <guid isPermaLink="true">https://gorpeln.top/article/17280983368</guid>
        <pubDate>2024-10-05</pubDate>
        <description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;数据无价，备份无忧。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;将其他平台数据备份到不同平台的好处：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;增强数据安全性&lt;/strong&gt;：通过定期备份到GitHub，即使又拍云服务出现问题，你的数据仍然安全。这为你的数据提供了额外的一层保护，尤其是使用&lt;strong&gt;国内免费服务&lt;/strong&gt;的用户。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;便于版本管理&lt;/strong&gt;：GitHub支持Git版本控制系统，这意味着你可以轻松追踪数据的变化历史，这对于需要保存多个版本的数据集或文档非常有用。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;自动化操作&lt;/strong&gt;：使用GitHub Actions，你可以设置自动化的工作流来定期执行备份脚本。这不仅减少了手动操作的需求，还降低了人为错误的风险。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;成本效益&lt;/strong&gt;：对于小规模项目或个人开发者来说，使用GitHub作为备份存储可能比租用额外的云存储空间更经济。特别是当使用GitHub的免费层级时。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;易于访问和分享&lt;/strong&gt;：GitHub上的数据可以通过简单的链接分享给他人，这对于公开数据集或开源项目尤其有益。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;预览&quot;&gt;预览&lt;/h3&gt;
&lt;p&gt;又拍云目录：
&lt;img src=&quot;https://img.gorpeln.top/blog/20241005111856740.png!gorpeln&quot; alt=&quot;20241005111856740&quot; /&gt;&lt;/p&gt;

&lt;p&gt;github目录：
&lt;img src=&quot;https://img.gorpeln.top/blog/20241005111856741.png!gorpeln&quot; alt=&quot;20241005111856741&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;操作示例&quot;&gt;操作示例&lt;/h3&gt;
&lt;h4 id=&quot;1-新增-workflow-yml-文件&quot;&gt;1. 新增 Workflow YML 文件&lt;/h4&gt;
&lt;p&gt;upyun_images_sync/.github/workflows/sync-images.yml&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;name: Sync Images from UpYun to GitHub

on:
  schedule:
    - cron: &apos;0 0 * * 3&apos;  # 每周三凌晨 0 点运行
  workflow_dispatch:  # 允许手动触发

jobs:
  sync-images:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v2

    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: &apos;3.x&apos;

    - name: Install dependencies
      run: |
        pip install gitpython

    - name: Run sync script
      env:
        UPYUN_FTP_HOST: $
        UPYUN_FTP_USER: $
        UPYUN_FTP_PASSWORD: $
        UPYUN_FTP_PATH: $
        LOCAL_DOWNLOAD_PATH: ./tmp
        REPO_PATH: ./repo
        GH_TOKEN: $
        REPO_OWNER: $
        REPO_NAME: $
        BRANCH_NAME: $
      run: |
        python3 sync_images.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;2-新建-python-同步脚本&quot;&gt;2. 新建 Python 同步脚本&lt;/h4&gt;
&lt;p&gt;upyun_images_sync/sync_images.py&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

import os
from ftplib import FTP
import git
import shutil

class MyFTP:
    def __init__(self, host, port=21):
        self.host = host
        self.port = port
        self.ftp = FTP()
        self.ftp.encoding = &apos;utf8&apos;
        self.file_list = []

    def login(self, username, password):
        try:
            self.ftp.connect(self.host, self.port)
            self.ftp.login(username, password)
            print(f&quot;成功登录到 {self.host}&quot;)
            print(f&quot;当前工作目录: {self.ftp.pwd()}&quot;)
        except Exception as err:
            print(f&quot;FTP 连接或登录失败，错误描述为：{err}&quot;)
            sys.exit(1)

    def download_file(self, local_file, remote_file):
        if os.path.exists(local_file):
            print(f&quot;{local_file} 已存在，跳过下载&quot;)
            return
        try:
            print(f&quot;下载文件 {remote_file} 到 {local_file}&quot;)
            buf_size = 1024
            with open(local_file, &apos;wb&apos;) as file_handler:
                self.ftp.retrbinary(f&apos;RETR {remote_file}&apos;, file_handler.write, buf_size)
        except Exception as err:
            print(f&quot;下载文件出错，出现异常：{err}&quot;)

    def download_file_tree(self, local_path, remote_path):
        try:
            print(f&quot;尝试切换到远程目录: {remote_path}&quot;)
            self.ftp.cwd(remote_path)
            print(f&quot;成功切换到远程目录: {remote_path}&quot;)
        except Exception as err:
            print(f&quot;远程目录 {remote_path} 不存在，继续... 具体错误描述为：{err}&quot;)
            return

        if not os.path.isdir(local_path):
            os.makedirs(local_path)
            print(f&quot;创建本地目录 {local_path}&quot;)

        print(f&quot;当前工作目录: {self.ftp.pwd()}&quot;)

        # 列出目录内容
        remote_files = self.ftp.nlst()
        print(f&quot;远程目录内容: {remote_files}&quot;)

        for remote_file in remote_files:
            local = os.path.join(local_path, remote_file)
            if remote_file in [&apos;.&apos;, &apos;..&apos;]:
                continue
            try:
                self.ftp.cwd(remote_file)
                print(f&quot;下载目录：{remote_file}&quot;)
                self.download_file_tree(local, os.path.join(remote_path, remote_file))
                self.ftp.cwd(&quot;..&quot;)
            except Exception:
                print(f&quot;下载文件：{remote_file}&quot;)
                self.download_file(local, os.path.join(remote_path, remote_file))

    def close(self):
        print(&quot;FTP退出&quot;)
        self.ftp.quit()

def sync_to_github(repo_path, branch_name):
    if os.path.exists(repo_path):
        shutil.rmtree(repo_path)
    os.makedirs(repo_path)

    repo_url = f&quot;https://{GH_TOKEN}@github.com/{REPO_OWNER}/{REPO_NAME}.git&quot;
    print(f&quot;克隆仓库: {repo_url}&quot;)
    try:
        repo = git.Repo.clone_from(repo_url, repo_path, branch=branch_name)
        print(f&quot;克隆仓库到 {repo_path}&quot;)
    except git.exc.GitCommandError as e:
        print(f&quot;克隆仓库失败: {e}&quot;)
        return

    images_dir = os.path.join(repo_path, &apos;images&apos;)
    if not os.path.exists(images_dir):
        os.makedirs(images_dir)

    shutil.copytree(LOCAL_DOWNLOAD_PATH, images_dir, dirs_exist_ok=True)
    print(f&quot;复制文件到 {images_dir}&quot;)

    repo.git.add(all=True)
    if repo.is_dirty():
        repo.index.commit(&quot;Sync images from UpYun&quot;)
        origin = repo.remote(name=&apos;origin&apos;)
        origin.push()
        print(&quot;推送更改到 GitHub 仓库&quot;)
    else:
        print(&quot;没有更改需要提交&quot;)

if __name__ == &quot;__main__&quot;:
    # 从环境变量中读取配置
    UPYUN_FTP_HOST = os.getenv(&apos;UPYUN_FTP_HOST&apos;)
    UPYUN_FTP_USER = os.getenv(&apos;UPYUN_FTP_USER&apos;)
    UPYUN_FTP_PASSWORD = os.getenv(&apos;UPYUN_FTP_PASSWORD&apos;)
    UPYUN_FTP_PATH = os.getenv(&apos;UPYUN_FTP_PATH&apos;, &apos;/&apos;)
    LOCAL_DOWNLOAD_PATH = os.getenv(&apos;LOCAL_DOWNLOAD_PATH&apos;, &apos;./tmp&apos;)
    REPO_PATH = os.getenv(&apos;REPO_PATH&apos;, &apos;./repo&apos;)
    GH_TOKEN = os.getenv(&apos;GH_TOKEN&apos;)
    REPO_OWNER = os.getenv(&apos;REPO_OWNER&apos;)
    REPO_NAME = os.getenv(&apos;REPO_NAME&apos;)
    BRANCH_NAME = os.getenv(&apos;BRANCH_NAME&apos;, &apos;master&apos;)

    # 创建 FTP 对象
    my_ftp = MyFTP(UPYUN_FTP_HOST)
    # 登录 FTP 服务器
    my_ftp.login(UPYUN_FTP_USER, UPYUN_FTP_PASSWORD)
    
    # 下载目录
    my_ftp.download_file_tree(LOCAL_DOWNLOAD_PATH, UPYUN_FTP_PATH)
    
    # 关闭 FTP 连接
    my_ftp.close()

    # 同步到 GitHub
    sync_to_github(REPO_PATH, BRANCH_NAME)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;3-授予-workflow-读写权限&quot;&gt;3. 授予 Workflow 读写权限&lt;/h4&gt;
&lt;p&gt;将本地的项目提交到github，然后设置Workflow 读写权限&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.top/blog/20241005111856742.png!gorpeln&quot; alt=&quot;20241005111856742&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;4-新增-secrets-变量&quot;&gt;4. 新增 Secrets 变量&lt;/h4&gt;
&lt;p&gt;在github上设置Secrets 变量&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.top/blog/20241005111856743.png!gorpeln&quot; alt=&quot;20241005111856743&quot; /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;序号&lt;/th&gt;
      &lt;th&gt;变量名&lt;/th&gt;
      &lt;th&gt;释义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;UPYUN_FTP_HOST&lt;/td&gt;
      &lt;td&gt;又拍云 FTP 主机地址&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;UPYUN_FTP_USER&lt;/td&gt;
      &lt;td&gt;又拍云 FTP 用户名&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;UPYUN_FTP_PASSWORD&lt;/td&gt;
      &lt;td&gt;又拍云 FTP 密码&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;UPYUN_FTP_PATH&lt;/td&gt;
      &lt;td&gt;又拍云 FTP 路径&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;GH_TOKEN&lt;/td&gt;
      &lt;td&gt;GitHub 个人访问令牌&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;REPO_OWNER&lt;/td&gt;
      &lt;td&gt;仓库所有者&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;REPO_NAME&lt;/td&gt;
      &lt;td&gt;仓库名称&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;BRANCH_NAME&lt;/td&gt;
      &lt;td&gt;分支名称（默认为 master）&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;变量详解：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UPYUN_FTP_HOST&lt;/code&gt;：参考&lt;a href=&quot;https://help.upyun.com/2015/12/28/%25e5%25a6%2582%25e4%25bd%2595%25e4%25bd%25bf%25e7%2594%25a8-ftp%25e3%2580%2581api-%25e4%25b8%258a%25e4%25bc%25a0%25e6%2596%2587%25e4%25bb%25b6/&quot;&gt;又拍云文档&lt;/a&gt;，直接使用&lt;code class=&quot;language-plaintext color-gray highlighter-rouge&quot;&gt;v0.ftp.upyun.com&lt;/code&gt;就行了&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UPYUN_FTP_USER&lt;/code&gt;：格式为 &lt;strong&gt;operator/bucket&lt;/strong&gt;，在又拍云 - 云存储 - 选择对应的bucket点击配置 - 存储管理 - 操作员授权 - 自己添加操作用户名和密码，假设你的又拍云云储存bucket的名称为upai-img，自定义的用户名为user，密码为123456，则UPYUN_FTP_USER就是 &lt;code class=&quot;language-plaintext color-gray highlighter-rouge&quot;&gt;user/upai-img&lt;/code&gt;，如果你看不懂我说的，参考&lt;a href=&quot;https://techs.upyun.com/videos/cdnpage/creating_storage.html&quot;&gt; 又拍云视频教程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UPYUN_FTP_PASSWORD&lt;/code&gt;：就是上面你自己设置的 &lt;code class=&quot;language-plaintext color-gray highlighter-rouge&quot;&gt;123456&lt;/code&gt;，&lt;a href=&quot;https://img.gorpeln.top/blog/20241005111856744.png!gorpeln&quot;&gt;图片示例&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UPYUN_FTP_PATH&lt;/code&gt;：直接使用 &lt;code class=&quot;language-plaintext color-gray highlighter-rouge&quot;&gt;/&lt;/code&gt; （根目录）就行了&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GH_TOKEN&lt;/code&gt;：选择github的 Settings - 点击右侧列表最下面的 Developer Settings - Personal access tokens - tokens (classic) - Generated new token (classic)，Note名字可以随意，Expiration时间选择 no Expiration,下面权限全选了，点击Generated token 就生成了想要的token，记得保存，他只显示一次，示例：&lt;code class=&quot;language-plaintext color-gray highlighter-rouge&quot;&gt;abc_123456789pUS123454321WmJkE987654321&lt;/code&gt;，&lt;a href=&quot;https://img.gorpeln.top/blog/20241005111856745.png!gorpeln&quot;&gt;图片示例&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;REPO_OWNER&lt;/code&gt;：就是你的github的用户名，我在github给这个项目创建仓库为https://github.com/gorpeln/upyun_images_sync，示例：&lt;code class=&quot;language-plaintext color-gray highlighter-rouge&quot;&gt;gorpeln&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;REPO_NAME&lt;/code&gt;：仓库链接后面的就是仓库名，示例：&lt;code class=&quot;language-plaintext color-gray highlighter-rouge&quot;&gt;upyun_images_sync&lt;/code&gt;，&lt;a href=&quot;https://img.gorpeln.top/blog/20241005111856746.png!gorpeln&quot;&gt;图片示例&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BRANCH_NAME&lt;/code&gt;：项目分支名，一般为master/main，示例：&lt;code class=&quot;language-plaintext color-gray highlighter-rouge&quot;&gt;master&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      </item>
    
      <item>
        <title>博客常见问题</title>
        <link>https://gorpeln.top/article/17265361548</link>
        <guid isPermaLink="true">https://gorpeln.top/article/17265361548</guid>
        <pubDate>2024-09-17</pubDate>
        <description>
&lt;div id=&quot;blog-problem&quot;&gt;
    &lt;p id=&quot;blog-problem-title&quot;&gt;博客目标？&lt;/p&gt;
    &lt;p id=&quot;blog-problem-des&quot;&gt;简洁、高效&lt;/p&gt;
&lt;/div&gt;

&lt;div id=&quot;blog-problem&quot;&gt;
    &lt;p id=&quot;blog-problem-title&quot;&gt;其他问题？&lt;/p&gt;
    &lt;p id=&quot;blog-problem-des&quot;&gt;还在整理中...&lt;/p&gt;
&lt;/div&gt;
</description>
      </item>
    
      <item>
        <title>网站被恶意镜像 — 如何保护博客流量及预防</title>
        <link>https://gorpeln.top/article/17245056864</link>
        <guid isPermaLink="true">https://gorpeln.top/article/17245056864</guid>
        <pubDate>2024-08-24</pubDate>
        <description>&lt;h3 id=&quot;什么是网站镜像&quot;&gt;什么是网站镜像？&lt;/h3&gt;
&lt;p&gt;网站镜像是指在互联网上出现一个与你的网站几乎一模一样的复制品，除了域名不同之外，其它所有内容都完全相同。这包括网站的布局、LOGO、版块结构等。&lt;/p&gt;

&lt;p&gt;通常，网站被恶意镜像的情况主要有两种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;完全镜像：这种情况是创建一个与您网站内容完全相同的站点，除了网址不同，其他一切都模仿您的设计和内容。&lt;/li&gt;
  &lt;li&gt;内容抓取：这种情况常见于博彩网站，它们会恶意抓取您的网页内容，正常浏览时隐藏掉原有内容，显示的却是他们自己的广告。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.top/blog/20240824212126440.png!gorpeln&quot; alt=&quot;20240824212126440&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在上述例子中，明显属于第一种情况：对方镜像了我的网站布局和结构。这种行为属于灰色 SEO 和黑帽 SEO 手法，目的是为了借助我博客的权重和流量来提升他们自己网站的排名。 
&lt;img src=&quot;https://img.gorpeln.top/blog/20240824212126441.png!gorpeln&quot; alt=&quot;20240824212126441&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;网站被镜像危害&quot;&gt;网站被镜像危害&lt;/h3&gt;
&lt;p&gt;从搜索引擎来讲，会对搜索引擎抓取不利，影响原本网站的正常抓取和识别，可能会导致原网站权重丢失，也有可能带来一定的误伤，搜索引擎会对网站进行识别，如果发现是镜像站，会导致网站被搜索引擎屏蔽，将失去搜索引擎带来的流量（这对个人博客来说是致命的）。&lt;/p&gt;

&lt;p&gt;对用户来讲，可能会被镜像网站欺骗，恶意广告插播或欺诈内容造成用户损失。&lt;/p&gt;

&lt;h3 id=&quot;网站被镜像了怎么办&quot;&gt;网站被镜像了怎么办&lt;/h3&gt;
&lt;h4 id=&quot;添加防镜像跳转代码&quot;&gt;添加防镜像跳转代码&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;zh&quot;&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
&amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
&amp;lt;title&amp;gt;not mirroring&amp;lt;/title&amp;gt;
&amp;lt;style&amp;gt;
    .alert-message {
        position: fixed;
        top: 45%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: #f8d7da;
        color: #721c24;
        padding: 20px;
        z-index: 10000;
        opacity: 1;
        transition: opacity 3s;
        border-radius:16px;
    }
    .alert-message.fade-out {
        opacity: 0;
    }
&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;script&amp;gt;
(function () {
    // 定义合法域名列表并Base64编码
    var validDomains = [&apos;Z29ycGVsbi50b3A=&apos;]; // gorpeln.top
    var redirectUrl = &apos;aHR0cHM6Ly9nb3JwZWxuLnRvcA==&apos;; // https://gorpeln.top
    var hostname = document.location.hostname + (document.location.port ? &apos;:&apos; + document.location.port : &apos;&apos;);

    function createWatermark(text) {
        var watermarkDiv = document.createElement(&apos;div&apos;);
        watermarkDiv.style.pointerEvents = &apos;none&apos;;
        watermarkDiv.style.position = &apos;fixed&apos;;
        watermarkDiv.style.top = &apos;0&apos;;
        watermarkDiv.style.left = &apos;-5%&apos;;
        watermarkDiv.style.width = &apos;110%&apos;;
        watermarkDiv.style.height = &apos;100%&apos;;
        watermarkDiv.style.zIndex = &apos;9999&apos;;
        watermarkDiv.style.opacity = &apos;0.1&apos;;
        watermarkDiv.style.background = &apos;transparent&apos;;
        watermarkDiv.style.overflow = &apos;hidden&apos;;
        watermarkDiv.style.display = &apos;flex&apos;;
        watermarkDiv.style.justifyContent = &apos;center&apos;;
        watermarkDiv.style.alignItems = &apos;center&apos;;
        watermarkDiv.style.flexWrap = &apos;wrap&apos;;

        var watermarkText = document.createElement(&apos;div&apos;);
        watermarkText.innerText = text;
        watermarkText.style.color = &apos;black&apos;;
        watermarkText.style.fontSize = &apos;30px&apos;;
        watermarkText.style.transform = &apos;rotate(-30deg)&apos;;
        watermarkText.style.whiteSpace = &apos;nowrap&apos;;
        watermarkText.style.margin = &apos;80px&apos;;

        for (var i = 0; i &amp;lt; 100; i++) {
            watermarkDiv.appendChild(watermarkText.cloneNode(true));
        }

        document.body.appendChild(watermarkDiv);
    }

    function showAlertMessage(message) {
        var alertMessage = document.createElement(&apos;div&apos;);
        alertMessage.className = &apos;alert-message&apos;;
        alertMessage.innerText = message;

        document.body.appendChild(alertMessage);

        // 3秒后添加fade-out类，使消息淡出
        setTimeout(function() {
            alertMessage.classList.add(&apos;fade-out&apos;);

            // 再等1秒（总共4秒）后删除元素
            setTimeout(function() {
                if (alertMessage.parentNode) {
                    alertMessage.parentNode.removeChild(alertMessage);
                }
            }, 200);
        }, 3000);

        // 5秒后跳转
        setTimeout(function() {
            window.location.replace(atob(redirectUrl));
        }, 5000);
    }

    // 检查当前域名是否在合法域名列表中
    if (!validDomains.includes(btoa(hostname))) {
        createWatermark(atob(validDomains[0])); // 使用合法域名列表中的第一个元素 
        showAlertMessage(&quot;警告：你当前浏览的页面非官方页面，可能存在有害信息！将在5秒后为你跳转至官方页面进行浏览！&quot;);
    }
})();
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;代码目的&quot;&gt;代码目的&lt;/h4&gt;
&lt;p&gt;这个代码的目的是，利用对方会无脑反代一切内容的机制，在所有页面内都插入检测 JS 代码，在网友访问时，检测当前域名是否为所设定自己博客的域名，如果不是所设定的博客域名则在网站背景中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;嵌入带域名水印&lt;/code&gt;并使用 confirm() 打断页面渲染，并弹出&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;弹窗警示&lt;/code&gt;用户&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;自动跳转回源站&lt;/code&gt;。
并且使用 JavaScript 动态插入水印 div 并不设置 id，class 等标识，防止对方通过u正则表达式匹配删除特定 div 元素。&lt;/p&gt;

&lt;h4 id=&quot;代码升级&quot;&gt;代码升级&lt;/h4&gt;
&lt;p&gt;因为 JavaScript 仍然是以明文方式暴露在 HTML 中，有正则表达式匹配风险，所以如果对方使用正则表达式破坏水印 JavaScript，则会导致水印无法正常显示。反制方法也很简单：使用 JavaScript 混淆。&lt;/p&gt;

&lt;p&gt;这里推荐一个 GitHub 上一个项目：https://github.com/javascript-obfuscator/javascript-obfuscator，该项目可以对 JavaScript 进行混淆，官方也提供了一个在线工具：https://obfuscator.io/#code&lt;/p&gt;

&lt;p&gt;我们可以借此对水印部分的 JavaScript 进行混淆，防止对水印 JavaScript 部分进行正则表达式匹配破坏，上面代码经过中等级混淆后如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function _0x1244(_0x2e9cd0,_0x16f71d){var _0x2ccdb5=_0x2ccd();return _0x1244=function(_0x124436,_0x222862){_0x124436=_0x124436-0x1d3;var _0x36d7fe=_0x2ccdb5[_0x124436];return _0x36d7fe;},_0x1244(_0x2e9cd0,_0x16f71d);}function _0x2ccd(){var _0x519334=[&apos;4159181SScBxf&apos;,&apos;center&apos;,&apos;110%&apos;,&apos;pointerEvents&apos;,&apos;80px&apos;,&apos;left&apos;,&apos;fixed&apos;,&apos;parentNode&apos;,&apos;117310NCrasO&apos;,&apos;width&apos;,&apos;33428dRtpro&apos;,&apos;wrap&apos;,&apos;hostname&apos;,&apos;fade-out&apos;,&apos;background&apos;,&apos;flex&apos;,&apos;30px&apos;,&apos;85638ogEylA&apos;,&apos;none&apos;,&apos;black&apos;,&apos;0.1&apos;,&apos;flexWrap&apos;,&apos;location&apos;,&apos;opacity&apos;,&apos;transform&apos;,&apos;10FNisEK&apos;,&apos;whiteSpace&apos;,&apos;position&apos;,&apos;body&apos;,&apos;100%&apos;,&apos;createElement&apos;,&apos;rotate(-30deg)&apos;,&apos;port&apos;,&apos;transparent&apos;,&apos;hidden&apos;,&apos;36vpXQzg&apos;,&apos;1078040hBJRkh&apos;,&apos;overflow&apos;,&apos;4510488GmCyEv&apos;,&apos;display&apos;,&apos;div&apos;,&apos;1243HhykLg&apos;,&apos;294OWGOMk&apos;,&apos;alert-message&apos;,&apos;-5%&apos;,&apos;margin&apos;,&apos;cloneNode&apos;,&apos;justifyContent&apos;,&apos;appendChild&apos;,&apos;alignItems&apos;,&apos;fontSize&apos;,&apos;zIndex&apos;,&apos;警告：你当前浏览的页面非官方页面，可能存在有害信息！将在5秒后为你跳转至官方页面进行浏览！&apos;,&apos;add&apos;,&apos;4592382EinlGm&apos;,&apos;36cjOBwx&apos;,&apos;innerText&apos;,&apos;removeChild&apos;,&apos;5neLlLf&apos;,&apos;style&apos;,&apos;includes&apos;];_0x2ccd=function(){return _0x519334;};return _0x2ccd();}(function(_0x4df09c,_0x8f741a){var _0x8f2856=_0x1244,_0x22b1d8=_0x4df09c();while(!![]){try{var _0x5f3be6=-parseInt(_0x8f2856(0x1f2))/0x1*(parseInt(_0x8f2856(0x201))/0x2)+-parseInt(_0x8f2856(0x1e1))/0x3+-parseInt(_0x8f2856(0x20e))/0x4*(-parseInt(_0x8f2856(0x1e5))/0x5)+-parseInt(_0x8f2856(0x1f9))/0x6*(-parseInt(_0x8f2856(0x1d5))/0x7)+-parseInt(_0x8f2856(0x20c))/0x8*(-parseInt(_0x8f2856(0x20b))/0x9)+parseInt(_0x8f2856(0x1f0))/0xa*(parseInt(_0x8f2856(0x1d4))/0xb)+parseInt(_0x8f2856(0x1e2))/0xc*(-parseInt(_0x8f2856(0x1e8))/0xd);if(_0x5f3be6===_0x8f741a)break;else _0x22b1d8[&apos;push&apos;](_0x22b1d8[&apos;shift&apos;]());}catch(_0x3801aa){_0x22b1d8[&apos;push&apos;](_0x22b1d8[&apos;shift&apos;]());}}}(_0x2ccd,0xe404e),(function(){var _0x2a9a37=_0x1244,_0x3507a2=[&apos;Z29ycGVsbi50b3A=&apos;],_0x49805e=&apos;aHR0cHM6Ly9nb3JwZWxuLnRvcA==&apos;,_0x2e6736=document[&apos;location&apos;][_0x2a9a37(0x1f4)]+(document[_0x2a9a37(0x1fe)][_0x2a9a37(0x208)]?&apos;:&apos;+document[&apos;location&apos;][&apos;port&apos;]:&apos;&apos;);function _0xc49f33(_0x38600e){var _0x202c5e=_0x2a9a37,_0x2660f1=document[&apos;createElement&apos;](&apos;div&apos;);_0x2660f1[&apos;style&apos;][_0x202c5e(0x1eb)]=_0x202c5e(0x1fa),_0x2660f1[_0x202c5e(0x1e6)][_0x202c5e(0x203)]=_0x202c5e(0x1ee),_0x2660f1[&apos;style&apos;][&apos;top&apos;]=&apos;0&apos;,_0x2660f1[_0x202c5e(0x1e6)][_0x202c5e(0x1ed)]=_0x202c5e(0x1d7),_0x2660f1[&apos;style&apos;][_0x202c5e(0x1f1)]=_0x202c5e(0x1ea),_0x2660f1[&apos;style&apos;][&apos;height&apos;]=_0x202c5e(0x205),_0x2660f1[_0x202c5e(0x1e6)][_0x202c5e(0x1de)]=&apos;9999&apos;,_0x2660f1[_0x202c5e(0x1e6)][_0x202c5e(0x1ff)]=_0x202c5e(0x1fc),_0x2660f1[&apos;style&apos;][_0x202c5e(0x1f6)]=_0x202c5e(0x209),_0x2660f1[_0x202c5e(0x1e6)][_0x202c5e(0x20d)]=_0x202c5e(0x20a),_0x2660f1[_0x202c5e(0x1e6)][_0x202c5e(0x20f)]=_0x202c5e(0x1f7),_0x2660f1[&apos;style&apos;][_0x202c5e(0x1da)]=_0x202c5e(0x1e9),_0x2660f1[_0x202c5e(0x1e6)][_0x202c5e(0x1dc)]=_0x202c5e(0x1e9),_0x2660f1[_0x202c5e(0x1e6)][_0x202c5e(0x1fd)]=_0x202c5e(0x1f3);var _0x323b98=document[_0x202c5e(0x206)](_0x202c5e(0x1d3));_0x323b98[_0x202c5e(0x1e3)]=_0x38600e,_0x323b98[_0x202c5e(0x1e6)][&apos;color&apos;]=_0x202c5e(0x1fb),_0x323b98[_0x202c5e(0x1e6)][_0x202c5e(0x1dd)]=_0x202c5e(0x1f8),_0x323b98[_0x202c5e(0x1e6)][_0x202c5e(0x200)]=_0x202c5e(0x207),_0x323b98[&apos;style&apos;][_0x202c5e(0x202)]=&apos;nowrap&apos;,_0x323b98[_0x202c5e(0x1e6)][_0x202c5e(0x1d8)]=_0x202c5e(0x1ec);for(var _0x17c22c=0x0;_0x17c22c&amp;lt;0x64;_0x17c22c++){_0x2660f1[_0x202c5e(0x1db)](_0x323b98[_0x202c5e(0x1d9)](!![]));}document[_0x202c5e(0x204)][_0x202c5e(0x1db)](_0x2660f1);}function _0x1aa9d7(_0x4e583e){var _0x37bf9d=_0x2a9a37,_0x4d1163=document[_0x37bf9d(0x206)](&apos;div&apos;);_0x4d1163[&apos;className&apos;]=_0x37bf9d(0x1d6),_0x4d1163[_0x37bf9d(0x1e3)]=_0x4e583e,document[_0x37bf9d(0x204)][_0x37bf9d(0x1db)](_0x4d1163),setTimeout(function(){var _0x3d022c=_0x37bf9d;_0x4d1163[&apos;classList&apos;][_0x3d022c(0x1e0)](_0x3d022c(0x1f5)),setTimeout(function(){var _0x68fa28=_0x3d022c;_0x4d1163[_0x68fa28(0x1ef)]&amp;amp;&amp;amp;_0x4d1163[_0x68fa28(0x1ef)][_0x68fa28(0x1e4)](_0x4d1163);},0xc8);},0xbb8),setTimeout(function(){var _0x528155=_0x37bf9d;window[_0x528155(0x1fe)][&apos;replace&apos;](atob(_0x49805e));},0x1388);}!_0x3507a2[_0x2a9a37(0x1e7)](btoa(_0x2e6736))&amp;amp;&amp;amp;(_0xc49f33(atob(_0x3507a2[0x0])),_0x1aa9d7(_0x2a9a37(0x1df)));}()));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;效果示意&quot;&gt;效果示意&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.top/blog/20240824212126442.png!gorpeln&quot; alt=&quot;20240824212126442&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;其他方法&quot;&gt;其他方法&lt;/h3&gt;
&lt;p&gt;1、向 google、域名注册商 、域名解析商举报&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;cloudflare 举报：&lt;em class=&quot;color-gray&quot;&gt;https://abuse.cloudflare.com/dmca&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;google 举报：&lt;em class=&quot;color-gray&quot;&gt;https://support.google.com/legal/answer/3110420?visit_id=638624243885343005-291301472&amp;amp;rd=1&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;阿里云举报：&lt;em class=&quot;color-gray&quot;&gt;https://report.aliyun.com/form/phishingForm&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2、设置 IP 黑名单&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;进入自己的服务器设置或者是虚拟主机管理，找到防火墙有的叫黑名单，把对方的 IP 地址添加进行，屏蔽访问和请求自己网站服务器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3、向谷歌申请移除镜像站的搜索结果&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;因为它会原样照搬反代网页，那其实你可以通过HTML 标记验证方式在 Google Search Console 里把他的反代域名也认证到你自己名下，然后在Google Search Console 向谷歌申请移除搜索结果，嘿嘿😋&lt;/li&gt;
&lt;/ul&gt;

</description>
      </item>
    
      <item>
        <title>Follow - 订阅一切</title>
        <link>https://gorpeln.top/article/17202356559</link>
        <guid isPermaLink="true">https://gorpeln.top/article/17202356559</guid>
        <pubDate>2024-07-06</pubDate>
        <description>&lt;h3 id=&quot;follow是什么&quot;&gt;Follow是什么？&lt;/h3&gt;
&lt;p&gt;Follow 是一款面向未来的信息浏览器，致力于将各种信息源整合在一个平台上，让用户便捷地获取和管理资讯。无论是传统的 RSS 订阅、社交媒体账号、博客、播客，还是实时通知，Follow 都能帮您一站式浏览。界面简洁，操作迅速，为用户提供现代化的阅读体验。&lt;/p&gt;

&lt;p&gt;Follow的&lt;strong&gt;slogan&lt;/strong&gt;是：Next generation information browser&lt;/p&gt;

&lt;p&gt;Follow的主要特色：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;信息一体化管理：&lt;em class=&quot;color-gray&quot;&gt;Follow 支持广泛的信息源，除了传统的 RSS，还包括 Twitter、Instagram、YouTube 等社交平台，用户可以在一个界面中浏览全部订阅内容，方便直观。&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;智能化 AI 功能：&lt;em class=&quot;color-gray&quot;&gt;内置的 AI 不仅能实现内容翻译和摘要，还能每日生成两次个性化报告，提炼重要信息，帮助用户轻松跟踪最关心的动态。此外，Follow 还能根据您的订阅喜好建立个性化知识库。&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;区块链激励机制：&lt;em class=&quot;color-gray&quot;&gt;Follow 通过区块链技术为活跃用户和内容创作者提供动力代币奖励，鼓励用户积极参与和分享内容，提升整体使用体验。&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;社交功能：&lt;em class=&quot;color-gray&quot;&gt;Follow 也具备社交平台属性，用户可以关注他人，分享订阅列表，发现新内容。支持与好友同步订阅列表，便捷地分享和发现优质资源。&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.top/blog/20240706111415430.png!gorpeln&quot; alt=&quot;20240706111415430&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;follow的访问隐忧&quot;&gt;Follow的访问隐忧&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;由于大平台都可以进行订阅，这种行为在某种程度上会触动大平台的利益。&lt;/li&gt;
  &lt;li&gt;follow的服务器并不在国内，且爬虫本身就自带法律风险。这些都有可能影响到国内对follow应用的访问。&lt;/li&gt;
  &lt;li&gt;即使现在可以使用，也并不代表未来能一直访问（直连）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;follow认证&quot;&gt;Follow认证&lt;/h3&gt;
&lt;p&gt;Follow的另一个亮点是支持打赏功能，你可以给你喜欢的文章进行打赏，当然前提是这个文章所有者进行了Follow认证，打赏的金额才能进入到他的账户中去。Follow使用的打赏货币名为power，是一种区块链货币，按照官方的说法会根据在Follow上的活跃度和贡献值来获取power。&lt;/p&gt;

&lt;h4 id=&quot;1获取认证码&quot;&gt;1.获取认证码&lt;/h4&gt;
&lt;p&gt;在Follow中订阅自己博客，然后点击订阅源，申请认证（Claim），便可获取认证码。如下&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;This message is used to verify that this feed (feedId:73252521066438656) belongs to me (userId:75520668589921280). Join me in enjoying the next generation information browser https://follow.is.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;2验证认证码&quot;&gt;2.验证认证码&lt;/h4&gt;
&lt;p&gt;在你自己博客中发布一篇博文，内容为刚生成的认证码，然后在Follow中再次点击申请认证（Claim），即可完成认证。认证完成后认证码的相关博文信息就可以删除了。&lt;/p&gt;

&lt;h3 id=&quot;follow订阅&quot;&gt;Follow订阅&lt;/h3&gt;
&lt;p&gt;目前gorpeln’s Blog已经过认证，在搜索框中直接输入『 gorpeln 』可直接订阅我的更新动态。或者直接填入gorpeln的RSS地址也是可以的 &lt;a href=&quot;https://gorpeln.top/feed.xml&quot;&gt;https://gorpeln.top/feed.xml&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.top/blog/20240706111415431.png!gorpeln&quot; alt=&quot;20240706111415431&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其他top订阅可以访问github开源项目&lt;a href=&quot;https://github.com/weekend-project-space/top-rss-list&quot;&gt;top-rss-list&lt;/a&gt;&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>双因素认证(2FA)实现原理</title>
        <link>https://gorpeln.top/article/17196724432</link>
        <guid isPermaLink="true">https://gorpeln.top/article/17196724432</guid>
        <pubDate>2024-06-29</pubDate>
        <description>&lt;p&gt;我们往往会在不同的网站上使用相同的密码，这样一旦一个网站账户的密码泄露，就会危及到其他使用相同密码的账户的安全，这也是最近的密码泄露事件造成如此大影响的原因。为了解决这个问题，一些网站在登录时要求除了输入账户密码之外，还需要输入另一个一次性密码，这就是常说的多步验证（多因子认证）。&lt;/p&gt;

&lt;h3 id=&quot;多因子认证&quot;&gt;多因子认证&lt;/h3&gt;

&lt;p&gt;多因子认证（Multi-factor Authentication），简称&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MFA&lt;/code&gt;。在现代网络安全领域，多因子认证已成为保护用户账户安全的重要手段，它要求用户提供两个或更多独立的认证因子，例如：账号密码+短信验证码、账号密码+邮箱验证码、账号密码+TOTP验证码等，当然对于Gtihub要求的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2FA&lt;/code&gt;，指的是Two-Factor Authentication双因子认证，与MFA的主要区别是认证因子的数量，从更广义的层面来看，2FA可以看作是MFA的一种特殊情况，即MFA的一个子集&lt;/p&gt;

&lt;p&gt;MFA的主要目的是增强安全性。相比于单一的用户名和密码认证，MFA增加了额外的验证方式，从而显著降低了账户被入侵的风险。即便攻击者获得了账号的用户名和密码，仍需要其他认证因子才能访问账户，极大地提高了账户的安全性&lt;/p&gt;

&lt;p&gt;常见的&lt;strong&gt;多因子认证&lt;/strong&gt;方式有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;短信验证码&lt;/code&gt;：这种验证方式非常广泛，在用户在登录时，系统会发送一个一次性验证码到用户的手机上，用户则需要在登录页面输入这个验证码来完成身份验证，这种认证方式的优点是简单方便，用户无需额外的设备或应用就能完成二次验证，缺点则主要是会产生短信费用，同时也可能会受到SIM卡交换攻击或短信拦截&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;邮件验证码&lt;/code&gt;：系统发送一次性验证码到用户的电子邮箱，用户需要在登录页面输入该验证码完成验证，邮箱验证码使用也较为广泛，这种认证方式优点是易于实现和使用，用户无需额外设备，只要有邮箱即可，缺点则主要是邮件响应速度较慢，用户体验不佳，同时安全性较低，邮箱可能被黑客入侵&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;生物识别认证&lt;/code&gt;：使用指纹、面部识别或声纹等生物特征进行身份验证，常用于高安全性需求场景，如解锁智能手机或访问敏感系统。这种认证方式优点是安全性极高，唯一性强、用户体验也好，快速便捷，缺点主要是设备要求高，需要设备支持指纹、面部解锁等，其次一些场景无法支持，例如WEB端，同时也有隐私问题需考虑&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;硬件令牌&lt;/code&gt;：这种常见于财务系统，使用独立的硬件设备生成一次性密码或进行物理验证，用户将硬件令牌插入计算机或使用NFC读取器完成验证。优点是极高的安全性，同时也能防止网络攻击，因为它不依赖移动设备或互联网连接，缺点也比较明显，依赖硬件，成本比较高，使用不方便&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;基于时间的一次性密码&lt;/code&gt;（TOTP）：基于时间生成的一次性密码，有标准的算法，通过标准算法来生成验证码，有许多免费的应用或小程序都能生成，用户需要输入应用生成的验证码来完成身份验证。这种认证方式的主要优点是安全性高，不依赖网络传输，多数MFA应用免费提供，缺点则主要是用户需要额外安装并配置应用&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;基于事件的一次性密码&lt;/code&gt;（HOTP）：基于事件计数生成的一次性密码，类似于TOTP，但使用事件计数而非时间。适用于硬件令牌。这种认证方式的优点是不依赖时间同步，适用于硬件设备，缺点则主要是使用体验不如TOTP方便&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;推送通知&lt;/code&gt;：通过认证应用发送推送通知到用户的设备，用户只需点击“批准”或“拒绝”即可完成身份验证，例如之前遇到过的Google账号认证，会发送消息到你登录Google账号的可信手机上，点击确定就能登录。这种认证方式的优点是：用户体验好，方便快捷、更加安全，防止中间人攻击，缺点则是需要互联网连接、依赖移动设备，也不是所有设备都支持&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;安全问题&lt;/code&gt;：用户设置一系列安全问题，登录时需回答这些问题进行验证。这种认证方式的优点是实施简单，无需额外设备，缺点则主要是安全性较低，容易被猜测或社交工程攻击，长时间不使用还容易遗忘，例如我小时候申请的QQ号密保问题是：你的梦想是什么？现在已经完全想不起来答案了&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中，基于时间的一次性密码&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TOTP&lt;/code&gt;是一种非常流行且标准化的多因子认证方式，尤其是在Web系统中，例如阿里云、腾讯云、Github、Google等诸多知名网站都支持TOTP多因子认证，另外一些应用较广的运维相关开源软件也都加入了对TOTP二次认证的支持，例如CODO、Jumpserver等，甚至出现了多因子认证约等于TOTP的现象&lt;/p&gt;

&lt;h3 id=&quot;totp&quot;&gt;TOTP&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.top/blog/20240629224723401.png!gorpeln&quot; alt=&quot;2fa&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.top/blog/20240629224723402.png!gorpeln&quot; alt=&quot;totp&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  # T表示当前时间的unix时间戳，T0表示初始时间（一般为0，可省略）
  # Period表示更新周期（一般为30秒）
  # C表示基于时间生成的计数
   C = (T - T0) / Period

  # K：加密密码，作为HMAC密码算法输入，由于只有客户端和服务端共享，因此在不知道K的情况下，无法生成，保证安全性。
  # C：计数器，客户端和服务端基于本地时间分别计算
  # h：表示使用密码技术得到的一次密码（但是由于h长度较大，不适合作为验证码，因此需要进一步截取
   h = HMAC(K, C)

  # otp：一次密码，通过对h进行截取处理（这里的digit代表需要截取的位数，通常情况下为6）
   otp = Trunc(h, digit)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TOTP&lt;/code&gt;（Time-Based One-Time Password）算法使用的是基于时间的一次性密码，这是一种广泛应用于两步验证过程的算法。TOTP的工作原理可以概括如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;HMAC算法&lt;/strong&gt;：TOTP是基于HMAC（Hash-Based Message Authentication Code）算法构建的，它结合了一个共享的秘密密钥和当前时间来生成一次性密码。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;共享密钥&lt;/strong&gt;：在设置Google Authenticator时，用户的设备和验证服务器之间会共享一个密钥。这个密钥是安全存储的，并且对于每个账户是唯一的。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;时间作为参数&lt;/strong&gt;：TOTP算法使用当前的时间作为变化因素。时间通常被分割成固定的时间片段（例如，每30秒一个片段）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;生成一次性密码&lt;/strong&gt;：
    &lt;ul&gt;
      &lt;li&gt;首先，当前时间被转换为一个计数器值，这通常是自Unix纪元（1970年1月1日）以来的30秒间隔数。&lt;/li&gt;
      &lt;li&gt;然后，使用HMAC算法结合这个计数器值和共享密钥来生成一个哈希值。&lt;/li&gt;
      &lt;li&gt;最后，从这个哈希值中提取一个较短的数字序列，通常是6到8位数，作为一次性密码。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;验证一次性密码&lt;/strong&gt;：当用户输入一次性密码时，验证服务器也会独立生成一个密码，使用相同的共享密钥和当前时间。如果两者匹配，验证成功。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;TOTP的优点：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;密码动态生成&lt;/strong&gt;：由于密码是基于当前时间生成的，它每30秒就会变化一次，并且只能使用一次，这种机制有效防止了密码重用和暴力破解攻击，提高了账户的安全性&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;无需网络&lt;/code&gt;：生成密码不依赖于网络连接，因为它基于时间和共享密钥，这增加了安全性和可用性&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;成本低&lt;/strong&gt;：相比硬件令牌等其他MFA方式，TOTP的成本更低，用户只需在手机上安装一个免费的应用程序即可实现多因子认证，而无需购买额外的硬件设备。对于企业而言，这降低了部署MFA的成本和复杂性&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;标准化&lt;/strong&gt;：TOTP遵循RFC 6238标准，确保了其跨平台的兼容性和一致性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em class=&quot;color-gray&quot;&gt;举一个不恰当但简单易懂的例子：首先使用手机扫描平台的二维码从服务器获取秘钥（假如为123456），那么TOTP客户端就可以根据秘钥和当前时间（假设为2024年09月12日16时48分15秒）生成一个6位的动态密码，时间截取日时分121648，123456×121648=15018175488直接截取后六位175488，那么48分的动态密码就是175488，同样的49分时，123456×121649=15018298944，得到动态密码为298944，这样当时间发生变化时每分钟都可以生成不一样的密码，同样的服务器也使用相同的方法根据秘钥和时间生成对应的密码，当你登录平台时手动输入TOTP客户端提供的动态密码给服务器，服务器会将结果与自己生成的密码比对，比对结果一致就可以正常登录了。当然这个例子只是帮助你理解TOTP，实际的商用环境下，加密方式肯定比我举例的这种方式复杂，需要考虑更多的因素，如果感兴趣可以去学习了解详细的TOTP算法。&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;totp客户端应用&quot;&gt;TOTP客户端应用&lt;/h3&gt;

&lt;p&gt;TOTP的算法是公开的，所以生成TOTP验证码也较为简单，国内各大云厂商的APP或是一些小程序也都有提供虚拟MFA的功能，例如腾讯云助手小程序等等，知名的MFA应用主要有Google验证器（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Google Authenticator&lt;/code&gt;）和微软验证器（Microsoft Authenticator）&lt;/p&gt;

&lt;h3 id=&quot;开启2fa&quot;&gt;开启2FA&lt;/h3&gt;

&lt;p&gt;以Github为例开启2FA。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Settings -&amp;gt; Password &amp;amp; authentication -&amp;gt; Two-factor authentication -&amp;gt; Authenticator app&lt;/li&gt;
  &lt;li&gt;生成绑定二维码&lt;/li&gt;
  &lt;li&gt;TOTP 应用/插件扫码绑定&lt;/li&gt;
  &lt;li&gt;登录账号后输入 TOTP 验证码&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;问题解答&quot;&gt;问题解答&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.时间T的值怎么选取？&lt;/strong&gt;   &lt;br /&gt;
因为时间每时每刻都在变化，如果选择一个变化太快的T（例如从某一时间点开始的秒数），那么用户来不及输入密码。如果选择一个变化太慢的T（例如从某一时间点开始的小时数），那么第三方攻击者就有充足的时间去尝试所有可能的一次性密码（试想6位数字的一次性密码仅仅有10^6种组合），降低了密码的安全性。除此之外，变化太慢的T还会导致另一个问题。如果用户需要在短时间内两次登录账户，由于密码是一次性的不可重用，用户必须等到下一个一次性密码被生成时才能登录，这意味着最多需要等待59分59秒！这显然不可接受。综合以上考虑，Google选择了30秒作为时间片，T的数值为从Unix epoch（1970年1月1日 00:00:00）来经历的30秒的个数&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.不在同一间隔内如何处理？&lt;/strong&gt; &lt;br /&gt;
由于网络延时、用户输入延迟等因素，可能当服务器端接收到一次性密码时，T的数值已经改变，这样就会导致服务器计算的一次性密码值与用户输入的不同，验证失败。解决这个问题个一个方法是，服务器计算当前时间片以及前面的n个时间片内的一次性密码值，只要其中有一个与用户输入的密码相同，则验证通过。当然，n不能太大，否则会降低安全性&lt;/p&gt;

&lt;p&gt;如果客户端和服务器的时钟有偏差，会造成与上面类似的问题，也就是客户端生成的密码和服务端生成的密码不一致。但是，如果服务器通过计算前n个时间片的密码并且成功验证之后，服务器就知道了客户端的时钟偏差。因此，下一次验证时，服务器就可以直接将偏差考虑在内进行计算，而不需要进行n次计算&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.如何保证安全？&lt;/strong&gt;  &lt;br /&gt;
在扫描 GitHub 给的绑定二维码时，如果被别人拍照、截图、数据劫持，二维码中的秘钥就会泄露，或者Authenticator 应用存储的秘钥被泄露，手机丢失、Authenticator 服务器被攻击等导致秘钥泄露，别人拿到了秘钥之后按照 TOTP 算法生成验证码肯定是有效的，不过前提是对方知道了你的 GitHub 的账号和密码。&lt;/p&gt;

&lt;p&gt;所以，选择一款可靠的 Authenticator 应用很关键，建议使用大厂的应用或者开源应用，甚至自己开发一款 TOTP 验证码生成应用。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>衣服的洗涤保养说明</title>
        <link>https://gorpeln.top/article/17146497169</link>
        <guid isPermaLink="true">https://gorpeln.top/article/17146497169</guid>
        <pubDate>2024-05-02</pubDate>
        <description>&lt;p&gt;你认真读过衣服上的洗衣符号嘛？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.top/blog/20240502170142831.png!gorpeln&quot; alt=&quot;20240502170142831&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一般来说，主要有以下几类&lt;/p&gt;
&lt;h3 id=&quot;水洗&quot;&gt;水洗&lt;/h3&gt;
&lt;p&gt;基本符号是一个水盆&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.top/blog/20240502170142832.png!gorpeln&quot; alt=&quot;20240502170142832&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;漂白&quot;&gt;漂白&lt;/h3&gt;
&lt;p&gt;基本符号是一个三角形
&lt;img src=&quot;https://img.gorpeln.top/blog/20240502170142833.png!gorpeln&quot; alt=&quot;20240502170142833&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;干燥&quot;&gt;干燥&lt;/h3&gt;
&lt;h4 id=&quot;自然干燥&quot;&gt;自然干燥&lt;/h4&gt;
&lt;p&gt;自然干燥也就是悬挂晾干，基本符号是一个正方形
&lt;img src=&quot;https://img.gorpeln.top/blog/20240502170142834.png!gorpeln&quot; alt=&quot;20240502170142834&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;翻转干燥&quot;&gt;翻转干燥&lt;/h4&gt;
&lt;p&gt;翻转干燥也就是烘干，正方形里面有个圆圈，也叫转笼翻转干燥&lt;/p&gt;

&lt;p&gt;圆点表示所允许的最高温度，一个圆点为较低温度（60℃），两个圆点为常规温度（80℃）。
&lt;img src=&quot;https://img.gorpeln.top/blog/20240502170142835.png!gorpeln&quot; alt=&quot;20240502170142835&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;熨烫&quot;&gt;熨烫&lt;/h3&gt;
&lt;p&gt;基本符号是个熨斗&lt;/p&gt;

&lt;p&gt;圆点表示熨斗底板的最高温度，一个圆点为110℃，二个圆点为150℃，三个圆点为200℃。
&lt;img src=&quot;https://img.gorpeln.top/blog/20240502170142836.png!gorpeln&quot; alt=&quot;20240502170142836&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;专业纺织品维护&quot;&gt;专业纺织品维护&lt;/h3&gt;
&lt;p&gt;基本符号为圆圈或圆形。包括专业干洗和专业湿洗&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.top/blog/20240502170142837.png!gorpeln&quot; alt=&quot;20240502170142837&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;end&quot;&gt;END&lt;/h3&gt;
&lt;p&gt;所以，最开始那个标签表示&lt;/p&gt;

&lt;p&gt;最高30度，常规洗涤程序，不可漂白，悬挂晾干，熨烫熨斗底板最高温度110℃，不可干洗&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>倒计时关闭的JS 公告</title>
        <link>https://gorpeln.top/article/17123887436</link>
        <guid isPermaLink="true">https://gorpeln.top/article/17123887436</guid>
        <pubDate>2024-04-06</pubDate>
        <description>&lt;p&gt;这是一个简洁高效的公告通知系统，它能够帮助您在个人博客中迅速传达重要更新、临时公告或其他关键信息给每一位访问者，确保他们能及时获取最新的站点动态。&lt;/p&gt;

&lt;p&gt;随着网络世界的日新月异，与读者保持有效沟通成为提升用户体验的关键环节之一。为了更好地服务于广大读者朋友，我在博客中集成了一套美观且功能齐全的公告通知模块。这套模块不仅具备直观醒目的视觉设计，还能灵活地调整样式、内容和显示时长，以满足各种场景需求。&lt;/p&gt;

&lt;h3 id=&quot;源码下载&quot;&gt;源码下载&lt;/h3&gt;
&lt;p&gt;文件下载：&lt;a href=&quot;https://gorpeln.lanzoul.com/ivzv21wpf0ti&quot;&gt;https://gorpeln.lanzoul.com/ivzv21wpf0ti&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;使用方法&quot;&gt;使用方法&lt;/h3&gt;
&lt;p&gt;放入要显示的页面 &lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.css&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;head&amp;gt; 
&amp;lt;!--其他引入--&amp;gt;
&amp;lt;link rel=&quot;stylesheet&quot; href=&quot;/assets/css/warning.min.css&quot; &amp;gt;
&amp;lt;!--其他引入--&amp;gt;
&amp;lt;/head&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.js&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;lt;!-- 公告 --&amp;gt;
&amp;lt;script src=&quot;../assets/js/warning.min.js&quot;&amp;gt; &amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
iziToast.show({
    title: &apos;Hi&apos;,
    message: &apos;本站启用新域名 gorpeln.top &apos;,
    icon: &apos;fal fa-exclamation-circle&apos;,
    color: &apos;yellow&apos;,
    time: 90000
});
&amp;lt;/script&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;效果&quot;&gt;效果&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.top/blog/20240406153223632.png!gorpeln&quot; alt=&quot;20240406153223632&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;div style=&quot;color: #888888;font-weight: 300;font-size:12px;margin-top:10px;&quot;&gt;参考链接：
    &lt;div&gt;
      
        https://www.yvii.cn/archives/1980.html
        
      
    &lt;/div&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>App更新总提醒缺少出口合规证明</title>
        <link>https://gorpeln.top/article/17113627324</link>
        <guid isPermaLink="true">https://gorpeln.top/article/17113627324</guid>
        <pubDate>2024-03-25</pubDate>
        <description>&lt;h3 id=&quot;问题&quot;&gt;问题&lt;/h3&gt;
&lt;p&gt;每次更新软件时，都要填写缺少出口合规证明，非常的麻烦。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.top/blog/20240325183212921.png!gorpeln&quot; alt=&quot;20240325183212921&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;解决方法&quot;&gt;解决方法&lt;/h3&gt;
&lt;p&gt;其实在xcode中修改应用的plist来让你在提交之前就告知Apple合规证明这个事情。&lt;/p&gt;

&lt;p&gt;添加&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ITSAppUsesNonExemptEncryption&lt;/code&gt;，键设置为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt;即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.top/blog/20240325183212922.png!gorpeln&quot; alt=&quot;20240325183212922&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;效果&quot;&gt;效果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.top/blog/20240325183212923.png!gorpeln&quot; alt=&quot;20240325183212923&quot; /&gt;&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>外链跳转到中间页</title>
        <link>https://gorpeln.top/article/17094338798</link>
        <guid isPermaLink="true">https://gorpeln.top/article/17094338798</guid>
        <pubDate>2024-03-03</pubDate>
        <description>&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.top/blog/20240303104439913.png!gorpeln&quot; alt=&quot;20240303104439913&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;网络安全的问题这些年越来越被关注，所以各大平台网站例如微博、微信、QQ、网易等，都在这几年为自家的网络产品添加了一个安全跳转的中台页面，甚至微博对于跳转链接必须是企业认证才能进入微博的安全白名单，可以说是把安全做到了&lt;del&gt;&lt;strong&gt;极致&lt;/strong&gt;&lt;/del&gt;。&lt;/p&gt;

&lt;p&gt;加了安全跳转中台以后，这样可以让自己的产品主域名成功与外链间接通过中台串联，而不是直接关系，增加安全跳转中台页面也间接提升了网络产品的用户体验。&lt;/p&gt;

&lt;h3 id=&quot;操作&quot;&gt;操作&lt;/h3&gt;
&lt;p&gt;新建 js 文件，如：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;safe.js&lt;/code&gt;。里面的网址为排除跳转中间页。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function checkParent(element, classNames) {
    while (element) {
        if (element.classList &amp;amp;&amp;amp; classNames.some(cn =&amp;gt; element.classList.contains(cn))) {
            return true;
        }
        element = element.parentElement;
    }
    return false;
}
var excludedClasses = [&apos;card-link&apos;, &apos;friend-item&apos;, &apos;contact-item&apos;, &apos;footer-item&apos;]; // 添加需要排除的a标签类名class
window.addEventListener(&apos;load&apos;, (event) =&amp;gt; {
    document.body.addEventListener(&apos;click&apos;, function(e) {
        let target = e.target;
        while (target &amp;amp;&amp;amp; target.nodeName !== &apos;A&apos;) {
            target = target.parentNode;
        }
        if (target &amp;amp;&amp;amp; target.nodeName === &apos;A&apos; &amp;amp;&amp;amp;
            !checkParent(target, excludedClasses) &amp;amp;&amp;amp;
            !target.href.includes(&apos;gorpeln.top&apos;) &amp;amp;&amp;amp;
            !target.href.includes(&apos;gorpeln.eu.org&apos;) &amp;amp;&amp;amp;
            !target.href.includes(&apos;lab.gorpeln.top&apos;) &amp;amp;&amp;amp;
            !target.href.includes(&apos;github.com&apos;) &amp;amp;&amp;amp;
            target.hostname !== window.location.hostname) {
            e.preventDefault();
            let encodedUrl = btoa(target.href); // Base64 encode the URL
            let url = &apos;/go-wild?target=&apos; + encodedUrl;
            window.open(url, &apos;_blank&apos;);
        }
    });
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;新建一个 html，如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;go-wild.html&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;tiaozhuan-all&quot;&amp;gt;
    &amp;lt;div class=&quot;tiaozhuan-nrong&quot;&amp;gt;
        &amp;lt;div class=&quot;tiaozhuan-title&quot;&amp;gt;即将离开 『 gorpeln&apos;s Blog 』 ，跳转到以下外部链接&amp;lt;/div&amp;gt;
        &amp;lt;div id=&quot;tiaozhuan-link&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;tiaozhuan-info&quot;&amp;gt;请自行识别该链接是否安全，并保管好个人信息。&amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;tiaozhuan-button&quot;&amp;gt;&amp;lt;a href=&apos;&apos; id=&apos;direct-link&apos;&amp;gt;继续访问&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
    const params = new URLSearchParams(window.location.search);
    const encodedTarget = params.get(&apos;target&apos;);
    const target = atob(encodedTarget); // 使用 atob 进行 Base64 解码

    if (target) {
        document.getElementById(&apos;direct-link&apos;).href = target;
        document.getElementById(&apos;tiaozhuan-link&apos;).textContent = &apos;&apos; + target; // 直接显示目标地址    
    } else {
        console.error(&apos;未指定重定向目标。&apos;);
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;相关 css，根据主题风格调整。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;body {
    background: #ececec;
}

.tiaozhuan-all {
    position: relative;
    box-shadow: rgba(0, 0, 0, 0.25) 0px 25px 50px -10px;
    border-radius: 10px;
    background: #fff url(../assets/img/go-wild.png) no-repeat center center / cover;
    color: #666;
    word-break: break-all;
    max-width: 700px;
    height: 350px;
    text-align: center;
    font-size: 0.85rem;
    overflow: hidden;
    margin: 100px auto 0;

    @include breakpoint(&apos;small&apos;) {
        aspect-ratio: 2 / 1;
        height: auto;
    }
}

.tiaozhuan-nrong {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    padding: 20px 20px 30px 20px;
}

.tiaozhuan-title {
    font-size: 1.3rem;
    color: #222;
    line-height: 1.4;
    margin-bottom: 4px;
}

.tiaozhuan-info {
    margin-top: 6px;
}

.tiaozhuan-button {
    margin-top: 20px;
}

.tiaozhuan-button a {
    color: #fc9151;
    border-radius: 4px;
    padding: 10px 30px;
    font-size: .85rem;
    border: 0.5px solid #fc9151;
    display: inline-block;
    text-decoration: none;

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后在页尾引用js文件即可，如&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script src=&quot;/js/safe.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;思路&quot;&gt;思路&lt;/h3&gt;
&lt;p&gt;js文件识别链接的a标签，并把链接用 base64 编码，同时排除一些不需要跳转中间页的class或网站。然后跳转到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;go-wild.html&lt;/code&gt;文件中（链接格式为/go-wild?target=base64编码），html文件承担了中间页具体信息，及跳转动作。如使用base64解码跳转的链接。&lt;/p&gt;

&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;
&lt;p&gt;对于浏览体验来说，多了一步跳转，总归是不好，但为了愉快的玩耍博客，稳妥一点更佳。如果觉得跳转中间页很烦人，浏览器可以装个 &lt;a href=&quot;https://chromewebstore.google.com/detail/skip-redirect/jaoafjdoijdconemdmodhbfpianehlon&quot;&gt;Skip Redirect&lt;/a&gt; 插件，告别所有网站的中间页跳转，直接抵达目标地址。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;div style=&quot;color: #888888;font-weight: 300;font-size:12px;margin-top:10px;&quot;&gt;参考链接：
    &lt;div&gt;
      
        https://koobai.com/zhongjiantiaozhuan
        
      
    &lt;/div&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>GitHub贡献者可获取 Stark 空投</title>
        <link>https://gorpeln.top/article/17087779433</link>
        <guid isPermaLink="true">https://gorpeln.top/article/17087779433</guid>
        <pubDate>2024-02-24</pubDate>
        <description>&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Starknet&lt;/code&gt; 正在向给 Github 按 star 排前 5000 个 repo 贡献过代码的人发钱，可以领领看。仔细研究了一下，最终我也拿到了这笔意外之财。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.top/blog/20240224203223424.jpg!gorpeln&quot; alt=&quot;20240224203223424&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;领取条件&quot;&gt;领取条件&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;在 2023 年 11 月 15 日之前，您至少向全球星数排名前 5,000 位的版本库提交了三次内容。其中至少一次提交发生在 2018 年或之后。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;即使不符合条件也先不要气馁，可以试着查一下资格，因为这 5000 个仓库的范围比较迷，我甚至都不记得自己是给哪个仓库贡献达标的……&lt;/p&gt;

&lt;p&gt;打开 &lt;a href=&quot;https://provisions.starknet.io&quot;&gt;provisions.starknet.io&lt;/a&gt;，点击 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Eligibility check only&lt;/code&gt;，选择 GitHub，输入 GitHub 用户名，点击 Go，如果提示 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Congratulations&lt;/code&gt;，那你就可以领到这笔钱了。&lt;/p&gt;

&lt;p&gt;接着点击 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Disconnect&lt;/code&gt;，点 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Claim STRK&lt;/code&gt;，按步骤下载浏览器插件（选哪个都可以，我选择的是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Argent X&lt;/code&gt;），创建一个钱包地址，在核验资格的步骤选择最后一个 GitHub，授权 GitHub 账号，然后这笔钱就到自己的钱包里了，不知道各位都领了多少，我领到了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;111.1&lt;/code&gt;。大约 1~2 分钟检查钱包到账情况。&lt;/p&gt;

&lt;h3 id=&quot;提现&quot;&gt;提现&lt;/h3&gt;
&lt;p&gt;接下来提现到支付宝。由于我国的加密货币政策原因，提现一定要选择安全正规的大平台进行，提现的大致过程如下&lt;/p&gt;

&lt;blockquote class=&quot;prompt-danger&quot;&gt;
  &lt;p&gt;提醒！ &lt;br /&gt;
此教程仅提供大致的加密货币提现方法，用于国内优秀开源贡献者兑换奖金。参与加密货币交易违反国内政策，投资须谨慎，加密货币风险高，请不要参与炒币，场外交易有刑事风险！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;申请交易所账号：我用的是 &lt;a href=&quot;https://www.okx.com/cn&quot;&gt;欧易&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;下载 APP 进行实名认证：有实名认证的交易所能更大程度确保资金来源安全&lt;/li&gt;
  &lt;li&gt;充币：币种选择 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;STRK&lt;/code&gt;，充至交易账户，打开钱包按步骤将币转入欧易提供的地址内，等待 5~10 分钟到账&lt;/li&gt;
  &lt;li&gt;卖出 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;STRK&lt;/code&gt; 获得 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;USDT&lt;/code&gt;：前往 STRK/USDT 的交易页面选择卖出，挂单，选市价委托（设置一个合理的限价也可以），数量 100%，等成交&lt;/li&gt;
  &lt;li&gt;提币：卖完到资产页面，把 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;USDT&lt;/code&gt; 余额从交易账户转到资金账户，点提币，C2C 交易，支付方式推荐选支付宝，选一个成交量比较高的靠谱的买家，填写支付宝账户并上传支付宝收款码，将 USDT 全部出售，1~20 分钟后即可到账，确认到账金额、付款方姓名正确后，回到交易所页面确认收款，交易完成&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote class=&quot;prompt-danger&quot;&gt;
  &lt;p&gt;最后再次提醒！ &lt;br /&gt;
此教程仅提供大致的加密货币提现方法，用于国内优秀开源贡献者兑换奖金。参与加密货币交易违反国内政策，投资须谨慎，加密货币风险高，请不要参与炒币，场外交易有刑事风险！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;
&lt;p&gt;感谢那些一直默默付出的贡献者们，这次空投给开源社区打了一剂振奋剂，也引来了不少别出心裁之人……
还有一些开源项目表示自己收到了许多垃圾 PR，或许是一些人希望借此抢下一次的空投。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>部署友链朋友圈</title>
        <link>https://gorpeln.top/article/17049566482</link>
        <guid isPermaLink="true">https://gorpeln.top/article/17049566482</guid>
        <pubDate>2024-01-11</pubDate>
        <description>&lt;h3 id=&quot;在线预览&quot;&gt;在线预览：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;/friends&quot;&gt;https://gorpeln.top/friends&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;github部署爬虫&quot;&gt;Github部署爬虫&lt;/h3&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;https://fcircle-doc.yyyzyyyz.cn/&quot;&gt;https://fcircle-doc.yyyzyyyz.cn/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;首先，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Import&lt;/code&gt;或&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fork&lt;/code&gt;此项目 &lt;a href=&quot;https://github.com/Rock-Candy-Tea/hexo-circle-of-friends&quot;&gt;https://github.com/Rock-Candy-Tea/hexo-circle-of-friends&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;编辑&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/hexo_circle_of_friend/fc_settings.yaml&lt;/code&gt;文件。根据注释，修改此处配置&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;LINK: [
     { link: &quot;https://gorpeln.top/links/&quot;, theme: &quot;commen2&quot; },  
     # 友链页地址，修改为你的友链页地址以及相应的主题，若无相应主题，尝试commen1或commen2。
     ...
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;针对还未适配主题或者有定制需求的用户，可以开启&lt;strong&gt;配置项友链&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SETTINGS_FRIENDS_LINKS: {
    enable: true,
    json_api: &quot;https://xxxx.com/xxx.json&quot;,
    # json_api：通过json格式配置友链，详见：https://fcircle-doc.yyyzyyyz.cn/#/developmentdoc?id=配置项json友链
    list: []
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后点击仓库的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Settings&lt;/code&gt;–&amp;gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Secrets&lt;/code&gt;–&amp;gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Actions&lt;/code&gt;—&amp;gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;New repository secret&lt;/code&gt;，添加4个变量。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GH_NAME&lt;/code&gt;(Github用户名)、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GH_EMAIL&lt;/code&gt;(Github账户邮箱)、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GH_TOKEN&lt;/code&gt;(Github密钥，具有repo以及workflow权限)、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;STORAGE_TYPE&lt;/code&gt;(数据库类型，填写sqlite)&lt;/p&gt;

&lt;p&gt;完成后，点击&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Settings&lt;/code&gt;–&amp;gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Actions&lt;/code&gt;—&amp;gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;General&lt;/code&gt;，勾选&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Actions&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;permissions&lt;/code&gt;—&amp;gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Allow all actions and reusable workflows&lt;/code&gt;以及&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Workflow permissions&lt;/code&gt;—&amp;gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Read and write permissions&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;vercel部署api&quot;&gt;Vercel部署API&lt;/h3&gt;
&lt;p&gt;新建项目，导入仓库，点击&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Deploy&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;等自动部署完成后，点击&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Settings&lt;/code&gt;–&amp;gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Environment Variables&lt;/code&gt;，添加4个变量，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GH_NAME&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GH_EMAIL&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GH_TOKEN&lt;/code&gt;（同上），还需添加&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VERCEL_ACCESS_TOKEN&lt;/code&gt;(&lt;strong&gt;Vercel&lt;/strong&gt;—&amp;gt;&lt;strong&gt;Settings&lt;/strong&gt;—&amp;gt;&lt;strong&gt;Tokens&lt;/strong&gt;—&amp;gt;&lt;strong&gt;Create&lt;/strong&gt;)。&lt;/p&gt;

&lt;h3 id=&quot;运行爬虫&quot;&gt;运行爬虫&lt;/h3&gt;
&lt;p&gt;回到Github仓库，点击&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Actions&lt;/code&gt;—&amp;gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update-friends-posts&lt;/code&gt;—&amp;gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Enable workflow&lt;/code&gt;—&amp;gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Run workflow&lt;/code&gt;—&amp;gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Run workflow&lt;/code&gt;。爬虫会自动爬取文章，同时Vercel会自动重新部署。&lt;/p&gt;

&lt;h3 id=&quot;绑定域名&quot;&gt;绑定域名&lt;/h3&gt;
&lt;p&gt;vercel遭遇域名污染导致无法访问，友链朋友圈的vercel部署也会受到影响，可以通过解析到自定义域名来解决。&lt;/p&gt;

&lt;p&gt;来到Vercel项目，点击&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Settings&lt;/code&gt;—&amp;gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Domains&lt;/code&gt;，根据提示输入域名并设置DNS即可。&lt;/p&gt;

&lt;p&gt;在链接后加上&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/all&lt;/code&gt;获取全部文章&lt;/p&gt;

&lt;h3 id=&quot;挂载前端代码&quot;&gt;挂载前端代码&lt;/h3&gt;
&lt;p&gt;博客新建一个页面，放入以下代码： &lt;br /&gt;
其中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apiurl&lt;/code&gt;就上在vercel上部署绑定的域名&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;!-- 挂载友链朋友圈的容器 --&amp;gt;
&amp;lt;div id=&quot;cf-container&quot;&amp;gt;与主机通讯中……&amp;lt;/div&amp;gt;
&amp;lt;!-- 加样式和功能代码 --&amp;gt;
&amp;lt;link rel=&quot;stylesheet&quot; href=&quot;https://fastly.jsdelivr.net/gh/lmm214/immmmm/themes/hello-friend/static/fcircle-beta.css&quot;&amp;gt;
&amp;lt;!-- 匹配自己的友链或加载后端数据 --&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
  var fdataUser = {
    //jsonurl: &apos;https://cdn.edui.fun/lmm.json&apos;,  //【推荐】json 匹配模式
    apiurl: &apos;https://hexo-circle-of-friends-lmm214.vercel.app/&apos;,  //自部署api
  }
&amp;lt;/script&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot; src=&quot;https://fastly.jsdelivr.net/gh/lmm214/immmmm/themes/hello-friend/static/fcircle-beta.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;div style=&quot;color: #888888;font-weight: 300;font-size:12px;margin-top:10px;&quot;&gt;参考链接：
    &lt;div&gt;
      
        https://blog.stevenw.cc/archives/BMn51E3Y
        
          &lt;br /&gt;
        
      
        https://immmmm.com/hi-friends-circle
        
      
    &lt;/div&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>2023 年度总结</title>
        <link>https://gorpeln.top/article/17040105944</link>
        <guid isPermaLink="true">https://gorpeln.top/article/17040105944</guid>
        <pubDate>2023-12-31</pubDate>
        <description>&lt;p style=&quot;display:none&quot;&gt;在辞旧迎新之际，回首2023年，我感慨万千。岁月如梭，光阴荏苒，每一天都是一段珍贵的时光，我努力在工作与生活的交错中寻找平衡，不断追求进步与成长。工作上，我面对各种挑战，不断突破自我，努力为团队和公司做出更大的贡献；生活中，我珍惜每一个温暖的瞬间，注重身心健康，与家人朋友共享美好时光。&lt;/p&gt;

&lt;p style=&quot;display:none&quot;&gt;在未来的道路上，我愿继续前行，怀揣着对生活的热爱和对未来的期许，不断探索前进，追逐梦想。感恩过去一年的所有经历和收获，期待着新的一年带来更多的挑战与机遇，也希望能与您一同分享成长的喜悦与收获。&lt;/p&gt;

&lt;h3 id=&quot;文雅&quot;&gt;文雅&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;度过了一年平静而充实的生活，专注于内心的宁静与成长。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.top/blog/20231231161634712.png!gorpeln&quot; alt=&quot;20231231161634712&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;通俗&quot;&gt;通俗&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;苟活着，一年啥也没干。&lt;/strong&gt;
&lt;img src=&quot;https://img.gorpeln.top/blog/20231231161634713.png!gorpeln&quot; alt=&quot;20231231161634713&quot; /&gt;&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>博客黑夜模式：Dark Reader 插件</title>
        <link>https://gorpeln.top/article/17016025546</link>
        <guid isPermaLink="true">https://gorpeln.top/article/17016025546</guid>
        <pubDate>2023-12-03</pubDate>
        <description>&lt;p&gt;亲爱的读者，现在你可以更加自由地调整我们的博客浏览模式了！如果你喜欢在夜晚或低光环境下浏览，我们建议你使用 &lt;strong&gt;Chrome&lt;/strong&gt; 浏览器，并安装 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dark Reader&lt;/code&gt; 插件。这个插件简单易用，适用于各类网站，包括我们的博客。启用黑夜模式，不仅有助于减轻眼睛的疲劳，还能提供更加舒适的阅读环境。安装 Dark Reader 插件只需几步简单操作，快来尝试吧，让博客在黑夜中焕发新光彩！&lt;/p&gt;

&lt;h3 id=&quot;dark-reader-简介&quot;&gt;Dark Reader 简介&lt;/h3&gt;

&lt;p&gt;适用于所有网站的暗色主题。关爱眼睛，就使用 Dark Reader 进行日常浏览。&lt;/p&gt;

&lt;p&gt;这是一个护眼扩展程序，通过实时生成黑暗主题，为每一个网站启用夜间模式。 Dark Reader 反转明亮的颜色，使网页内容具有高对比度并易于在夜间阅读。&lt;/p&gt;

&lt;p&gt;您可以调整亮度、对比度，应用棕褐色滤镜、黑暗模式，设置字体和忽略的网站列表。&lt;/p&gt;

&lt;p&gt;我们可能会要求您通过捐款来支持应用程序的开发。您可能会在设置弹出窗口中看到有关 Dark Reader 的新闻。有针对经验丰富的用户的开发人员工具。&lt;/p&gt;

&lt;p&gt;Dark Reader 无广告，也不会向任何地方发送用户的数据。它完全开源 &lt;a href=&quot;https://github.com/darkreader/darkreader&quot;&gt;https://github.com/darkreader/darkreader&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;下载安装&quot;&gt;下载安装&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;插件下载地址：&lt;/strong&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/dark-reader/eimadpbcbfnmbkopoojfekhnkhdbieeh&quot;&gt;https://chrome.google.com/webstore/detail/dark-reader/eimadpbcbfnmbkopoojfekhnkhdbieeh&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;开源地址：&lt;/strong&gt;&lt;a href=&quot;https://github.com/darkreader/darkreader&quot;&gt;https://github.com/darkreader/darkreader&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;蓝奏云：&lt;/strong&gt;&lt;a href=&quot;https://gorpeln.lanzoul.com/itV2o1gt1uve%0A&quot;&gt;https://gorpeln.lanzoul.com/itV2o1gt1uve&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装方法：&lt;/strong&gt; &lt;br /&gt;
　　方法1. chrome插件商店下载直接安装   &lt;br /&gt;
　　方法2. 开源地址、蓝奏云下载的直接解压，在chrome浏览器输入栏输入&lt;strong&gt;chrome://extensions/&lt;/strong&gt;，开启开发者模式，点击&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;加载已解压的扩展程序&lt;/code&gt;&lt;/strong&gt;即可。
　　&lt;/p&gt;
&lt;h3 id=&quot;使用效果&quot;&gt;使用效果&lt;/h3&gt;
&lt;p&gt;Dark Reader 启用前
&lt;img src=&quot;https://img.gorpeln.top/blog/20231203192234541.png!gorpeln&quot; alt=&quot;20231203192234541&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Dark Reader 启用后&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.top/blog/20231203192234542.png!gorpeln&quot; alt=&quot;20231203192234542&quot; /&gt;
&lt;img src=&quot;https://img.gorpeln.top/blog/20231203192234543.png!gorpeln&quot; alt=&quot;20231203192234543&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;使用方法&quot;&gt;使用方法&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.top/blog/20231203192234544.png!gorpeln&quot; alt=&quot;20231203192234544&quot; /&gt;
&lt;img src=&quot;https://img.gorpeln.top/blog/20231203192234545.png!gorpeln&quot; alt=&quot;20231203192234545&quot; /&gt;
&lt;img src=&quot;https://img.gorpeln.top/blog/20231203192234546.png!gorpeln&quot; alt=&quot;20231203192234546&quot; /&gt;
&lt;img src=&quot;https://img.gorpeln.top/blog/20231203192234547.png!gorpeln&quot; alt=&quot;20231203192234547&quot; /&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>个性二维码合集</title>
        <link>https://gorpeln.top/article/16990919984</link>
        <guid isPermaLink="true">https://gorpeln.top/article/16990919984</guid>
        <pubDate>2023-11-04</pubDate>
        <description>&lt;p&gt;探索个性二维码，每个都是数字艺术的小宝藏。这些小图案背后蕴含着独特的故事。扫一扫，用手机开启一场别样的冒险，发现属于你的精彩故事。或许，在其中的某一张，你将找到属于自己的独特之旅。数字艺术的魅力，从这些个性十足的二维码开始。让它们为你的日常生活注入新奇，感受创意的奇妙。快来和我一同探索这个数字世界的神秘角落吧！&lt;/p&gt;

&lt;html lang=&quot;zh&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;style&gt;
        .slideshow-container {
            max-width: 500px;
            position: relative;
            margin: auto;
        }

        .mySlides {
            display: none;
        }

        .prev, .next {
            position: absolute;
            top: 50%;
            width: auto;
            padding: 16px;
            margin-top: -22px;
            color: white;
            font-weight: bold;
            font-size: 18px;
            transition: 0.6s ease;
            border-radius: 0 3px 3px 0;
            cursor: pointer;
            background-color: rgba(0, 0, 0, 0.8);
        }

        .next {
            right: 0;
            border-radius: 3px 0 0 3px;
        }

        .prev:hover, .next:hover {
            background-color: rgba(0, 0, 0, 1);
        }

    .thumbnail-container {
        text-align: center;
        margin-top: 20px;
        display: flex;
        flex-wrap: wrap; /* 开启自动换行 */
        justify-content: center; /* 让缩略图水平居中 */
    }

    .thumbnail {
        width: 60px;
        height: 60px;
        margin: 5px; /* 调整缩略图之间的间距 */
        cursor: pointer;
    }

    .thumbnail.active {
        border: 2px solid #333; /* 激活状态添加边框 */
    }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;!-- 添加更多的图片 --&gt;
&lt;div class=&quot;slideshow-container&quot;&gt;

	&lt;script&gt;
 		for (var i = 1; i &lt; 15; i++) {
            document.write(&quot;&lt;div class=&apos;mySlides&apos;&gt;&lt;img src=&apos;https://img.gorpeln.top/p/qrcode_&quot; + i + &quot;.jpg&apos; style=&apos;width:100%&apos;&gt;&lt;/div&gt;&quot;);       
        }
	&lt;/script&gt;


    &lt;a class=&quot;prev safe-item-auto-load&quot; onclick=&quot;plusSlides(-1)&quot;&gt;&amp;#10094;&lt;/a&gt;
    &lt;a class=&quot;next safe-item-auto-load&quot; onclick=&quot;plusSlides(1)&quot;&gt;&amp;#10095;&lt;/a&gt;
&lt;/div&gt;

&lt;!-- 添加更多的缩略图 --&gt;
&lt;div class=&quot;thumbnail-container&quot;&gt;

    &lt;img class=&quot;thumbnail&quot; src=&quot;https://img.gorpeln.top/p/qrcode_1.jpg&quot; onclick=&quot;currentSlide(1)&quot; /&gt;
    &lt;img class=&quot;thumbnail&quot; src=&quot;https://img.gorpeln.top/p/qrcode_2.jpg&quot; onclick=&quot;currentSlide(2)&quot; /&gt;
    &lt;img class=&quot;thumbnail&quot; src=&quot;https://img.gorpeln.top/p/qrcode_3.jpg&quot; onclick=&quot;currentSlide(3)&quot; /&gt;
    &lt;img class=&quot;thumbnail&quot; src=&quot;https://img.gorpeln.top/p/qrcode_4.jpg&quot; onclick=&quot;currentSlide(4)&quot; /&gt;
    &lt;img class=&quot;thumbnail&quot; src=&quot;https://img.gorpeln.top/p/qrcode_5.jpg&quot; onclick=&quot;currentSlide(5)&quot; /&gt;
    &lt;img class=&quot;thumbnail&quot; src=&quot;https://img.gorpeln.top/p/qrcode_6.jpg&quot; onclick=&quot;currentSlide(6)&quot; /&gt;
    &lt;img class=&quot;thumbnail&quot; src=&quot;https://img.gorpeln.top/p/qrcode_7.jpg&quot; onclick=&quot;currentSlide(7)&quot; /&gt;
    &lt;img class=&quot;thumbnail&quot; src=&quot;https://img.gorpeln.top/p/qrcode_8.jpg&quot; onclick=&quot;currentSlide(8)&quot; /&gt;
    &lt;img class=&quot;thumbnail&quot; src=&quot;https://img.gorpeln.top/p/qrcode_9.jpg&quot; onclick=&quot;currentSlide(9)&quot; /&gt;
    &lt;img class=&quot;thumbnail&quot; src=&quot;https://img.gorpeln.top/p/qrcode_10.jpg&quot; onclick=&quot;currentSlide(10)&quot; /&gt;
    &lt;img class=&quot;thumbnail&quot; src=&quot;https://img.gorpeln.top/p/qrcode_11.jpg&quot; onclick=&quot;currentSlide(11)&quot; /&gt;
    &lt;img class=&quot;thumbnail&quot; src=&quot;https://img.gorpeln.top/p/qrcode_12.jpg&quot; onclick=&quot;currentSlide(12)&quot; /&gt;
  	&lt;img class=&quot;thumbnail&quot; src=&quot;https://img.gorpeln.top/p/qrcode_13.jpg&quot; onclick=&quot;currentSlide(13)&quot; /&gt;
    &lt;img class=&quot;thumbnail&quot; src=&quot;https://img.gorpeln.top/p/qrcode_14.jpg&quot; onclick=&quot;currentSlide(14)&quot; /&gt;

&lt;/div&gt;

&lt;script&gt;
    let slideIndex = 1;
    showSlides(slideIndex);

    function plusSlides(n) {
        showSlides(slideIndex += n);
    }

    function currentSlide(n) {
        showSlides(slideIndex = n);
    }

    function showSlides(n) {
        let i;
        let slides = document.getElementsByClassName(&quot;mySlides&quot;);
        let thumbnails = document.getElementsByClassName(&quot;thumbnail&quot;);

        if (n &gt; slides.length) {
            slideIndex = 1;
        }

        if (n &lt; 1) {
            slideIndex = slides.length;
        }

        for (i = 0; i &lt; slides.length; i++) {
            slides[i].style.display = &quot;none&quot;;
        }

        for (i = 0; i &lt; thumbnails.length; i++) {
            thumbnails[i].classList.remove(&quot;active&quot;);
        }

        slides[slideIndex - 1].style.display = &quot;block&quot;;
        thumbnails[slideIndex - 1].classList.add(&quot;active&quot;);
    }
&lt;/script&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;/body&gt;
&lt;/html&gt;
</description>
      </item>
    
      <item>
        <title>Sublime Text 常用插件</title>
        <link>https://gorpeln.top/article/16962230954</link>
        <guid isPermaLink="true">https://gorpeln.top/article/16962230954</guid>
        <pubDate>2023-10-02</pubDate>
        <description>&lt;h4 id=&quot;一package-control无法使用解决办法&quot;&gt;一、Package Control无法使用解决办法&lt;/h4&gt;

&lt;p&gt;最新升级了MacOS到Ventura和Sonoma,发现安装Sublime Text4之后，无法使用Install Package Control，即使安装了Install Package Control也无法正常使用Install Pakcage。&lt;/p&gt;

&lt;p&gt;解决方法：&lt;/p&gt;

&lt;p&gt;下载：&lt;a href=&quot;https://github.com/wbond/package_control/releases&quot;&gt;PackageControl&lt;/a&gt; （https://github.com/wbond/package_control/releases）&lt;/p&gt;

&lt;p&gt;之后得到一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Package.Control.sublime.package&lt;/code&gt;文件，将文件重命名为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Package Control.sublime-package&lt;/code&gt;&lt;br /&gt;
随后将这个文件放置到插件安装目录的（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Installed Packages&lt;/code&gt;）目录下，路径为：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/Users/用户名/Library/Application Support/Sublime Text/Installed Packages
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;二package-control使用方法&quot;&gt;二、Package Control使用方法&lt;/h4&gt;

&lt;p&gt;为插件管理包，通过快捷键 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ctrl + Shift + P&lt;/code&gt;
打开，之后可以很方便的浏览、安装和卸载 Sublime Text 中的插件。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;插件安装：输入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;install&lt;/code&gt; &lt;br /&gt;
  后选择 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Package Control: Install Package&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;插件列表：输入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;list&lt;/code&gt; &lt;br /&gt;
  后选择 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Package Control: List Packages&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;插件删除：输入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;remove&lt;/code&gt; &lt;br /&gt;
  后选择 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Package Control: Remove Packages&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;三常用插件&quot;&gt;三、常用插件：&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ChineseLocalization&lt;/code&gt; 汉化包&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ColorHelper&lt;/code&gt; 显示所选颜色值的颜色&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HTML-CSS-JS Prettify&lt;/code&gt; 一款集成了格式化（美化）html、css、js三种文件类型的插件&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Auto Close HTML Tags&lt;/code&gt; 写HTML代码时，自动补全闭合标签&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BracketHighlighter&lt;/code&gt; 代码匹配，可以匹配括号，引号等符号内的范围&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Alignment&lt;/code&gt; 使多行代码中的等号对齐&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AutoFileName&lt;/code&gt; 快捷输入文件名&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SublimeCodeInte&lt;/code&gt; 代码提示、补全&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SublimeLinter&lt;/code&gt; 代码检查的功能&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;View In Browser&lt;/code&gt; Sublime Text 保存后网页自动同步更新&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LiveReload&lt;/code&gt; 调试网页实时自动更新&lt;/li&gt;
&lt;/ul&gt;
</description>
      </item>
    
      <item>
        <title>博客评论时一键填写自己的信息</title>
        <link>https://gorpeln.top/article/16959932733</link>
        <guid isPermaLink="true">https://gorpeln.top/article/16959932733</guid>
        <pubDate>2023-09-29</pubDate>
        <description>&lt;p&gt;使用浏览器书签实现博客网站留言评论时&lt;strong&gt;一键填写昵称/邮箱/网址&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;具体的使用方法：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;将本页添加到收藏夹保存为书签；&lt;/li&gt;
  &lt;li&gt;右键刚刚创建的书签，选择“编辑”或“属性”；&lt;/li&gt;
  &lt;li&gt;将“名称”一栏改为“一键填写留言评论信息”（见名知意即可，名称可换成其它的），并将“网址”或“地址”或“url”一栏原有的网址链接替换成上述 javascript 代码（代码里面的相关个人信息改为自己的哦~~），确定即可。&lt;/li&gt;
  &lt;li&gt;以后遇到留言评论时，点一个这个书签即可自动一键填写个人信息！&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript: void
function() {
    var lauthor = [&quot;#author&quot;,&quot;input[name=&apos;comname&apos;]&quot;,&quot;#inpName&quot;,&quot;input[name=&apos;author&apos;]&quot;,&quot;#ds-dialog-name&quot;,&quot;#name&quot;,&quot;input[name=&apos;nick&apos;]&quot;,&quot;#comment_author&quot;],
	lmail =[&quot;#mail&quot;,&quot;#email&quot;,&quot;input[name=&apos;commail&apos;]&quot;,&quot;#inpEmail&quot;,&quot;input[name=&apos;email&apos;]&quot;,&quot;#ds-dialog-email&quot;,&quot;input[name=&apos;mail&apos;]&quot;,&quot;#comment_email&quot;],
	lurl =[&quot;#url&quot;,&quot;input[name=&apos;comurl&apos;]&quot;,&quot;#inpHomePage&quot;,&quot;#ds-dialog-url&quot;,&quot;input[name=&apos;url&apos;]&quot;,&quot;input[name=&apos;website&apos;]&quot;,&quot;#website&quot;,&quot;input[name=&apos;link&apos;]&quot;,&quot;#comment_url&quot;];
    for (i = 0; i &amp;lt; lauthor.length; i++) {
        var author = document.querySelector(lauthor[i]);
        if (author != null) {
            author.value = &apos;你的昵称&apos;;
            author.dispatchEvent(new Event(&apos;input&apos;));
            author.dispatchEvent(new Event(&apos;change&apos;));
            break;
        }
    }
    for (j = 0; j &amp;lt; lmail.length; j++) {
        var mail = document.querySelector(lmail[j]);
        if (mail != null) {
            mail.value = &apos;你的邮箱&apos;;
            mail.dispatchEvent(new Event(&apos;input&apos;));
            mail.dispatchEvent(new Event(&apos;change&apos;));
            break;
        }
    }
    for (k = 0; k &amp;lt; lurl.length; k++) {
        var url = document.querySelector(lurl[k]);
        if (url != null) {
            url.value = &apos;你的网址&apos;;
            url.dispatchEvent(new Event(&apos;input&apos;));
            url.dispatchEvent(new Event(&apos;change&apos;));
            break;
        }
    }
    return ! 1;
} ()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
      </item>
    
      <item>
        <title>8周年：博海泛舟，共赴时光之旅</title>
        <link>https://gorpeln.top/article/16927632006</link>
        <guid isPermaLink="true">https://gorpeln.top/article/16927632006</guid>
        <pubDate>2023-08-23</pubDate>
        <description>&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.top/blog/20200823120000260.jpg!gorpeln&quot; alt=&quot;20200823120000260&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　在这片浩瀚无垠的数字海洋中，每一滴浪花都承载着思想的重量，每一缕风都传递着智慧的低语。今日，我以笔为篙，轻划过时间的河面，与诸君共庆，这不平凡的博客八周年纪念。八年，于历史长河不过是短暂一瞬，于个人，则是无数次心灵触碰与智慧火花的璀璨绽放。&lt;/p&gt;

&lt;p&gt;　　回望来时路，初踏博园，心怀稚嫩与憧憬，文字间洋溢着探索未知的勇气。彼时，屏幕前的每一次敲击，不仅是对世界的好奇询问，更是自我对话的深刻记录。岁月悠悠，文字如织，从青涩到成熟，从单一到多元，这片小小的天地见证了我思维的蜕变与视野的拓宽。&lt;/p&gt;

&lt;p&gt;　　八载春秋，风雨兼程，博客不仅是个人思想的栖息地，更成为了连接你我的桥梁。每一位读者的驻足，每一条留言的温暖，都是推动我继续前行的不竭动力。你们的鼓励与批评，如同星辰照亮夜空，引领着我不断攀登知识与理解的新高峰。在此，衷心感谢每一位同行者，是你们赋予了这段旅程无尽的意义与价值。&lt;/p&gt;

&lt;p&gt;　　值此纪念之际，我不禁思考，何为博客之于我的真正意义？或许，它是一场自我发现的旅行，一场与时代共振的交响，更是一次次灵魂深处的对话。在这里，我们共同探讨生活的哲学，分享成长的喜悦，面对挑战的坚韧，以及对美好未来的无限向往。&lt;/p&gt;

&lt;p&gt;　　展望未来，我满怀期待。愿以此刻为新的起点，继续在文字的田野上深耕细作，播撒更多思考的种子，收获更加丰富多彩的精神果实。我期许，未来的日子里，能与诸位携手，在知识的海洋中乘风破浪，探索更多的未知，分享更深的感悟。&lt;/p&gt;

&lt;p&gt;　　让我们以笔为舟，以梦为帆，继续在这广阔无边的网络世界里，书写属于我们的故事，共同见证每一个思想的光辉瞬间。博客八周年，不仅是一段旅程的总结，更是下一段伟大航程的启航。&lt;/p&gt;

&lt;p&gt;　　最后，再次感谢您的陪伴与支持，愿我们的心灵之舟，永远向着光明与智慧的彼岸航行。
　　
　　&lt;img src=&quot;https://img.gorpeln.top/blog/20200823120000261.jpg!gorpeln&quot; alt=&quot;20200823120000261&quot; /&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>同一台电脑上使用多个GitHub账号</title>
        <link>https://gorpeln.top/article/16895899334</link>
        <guid isPermaLink="true">https://gorpeln.top/article/16895899334</guid>
        <pubDate>2023-07-17</pubDate>
        <description>&lt;h3 id=&quot;使用需求&quot;&gt;使用需求&lt;/h3&gt;

&lt;blockquote class=&quot;prompt-info&quot;&gt;
  &lt;p&gt;通常情况下，我们会有两个 github 账号：一个是公司的，另一个是私人的。由于 github 是使用 SSH key 的 fingerprint (对应的公钥id_rsa_pub)来判定你是哪个账户，而不是通过用户名，如果是在多台电脑上使用一个账号，可以为该账号添加多个 SSH key，如果是一台电脑使用多个账号，则分别生成多个 SSH key 添加到对应的账户即可。所以本文要实现的是公号和私号在 git 上同时使用，两者互不干扰。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;步骤一生成多个-ssh-key&quot;&gt;步骤一：生成多个 SSH key&lt;/h3&gt;
&lt;p&gt;为了举例方便，这里使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;one&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;two&lt;/code&gt; 两个账户。
使用cd ~/.ssh切换工作目录，然后使用如下命令生成两个钥匙，中间一路回车。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssh-keygen -t rsa -f ~/.ssh/id_rsa_one -C &quot;one@xxx.com&quot;
ssh-keygen -t rsa -f ~/.ssh/id_rsa_two -C &quot;two@xxx.com&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样会在~/.ssh目录下生成四个文件：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;id_rsa.one      //账号 one 的私钥
id_rsa.one.pub  //账号 one 的公钥
id_rsa.two
id_rsa.two.pub
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;步骤二创建配置文件-config&quot;&gt;步骤二：创建配置文件 config&lt;/h3&gt;
&lt;p&gt;在 ~/.ssh目录下新建 config 文件，令不同 Host 实际映射到同一 HostName，但密钥文件不同。根据自己情况修改&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;account-one&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;account-name&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;account-two&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;accountTwo-name&lt;/code&gt;的值。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# --- 第一个账号 ---
Host account-one    # 如：gorpeln
	HostName github.com
	User account-name  # 如：gorpeln
	PreferredAuthentications publickey
	IdentityFile ~/.ssh/id_rsa_one
	UseKeychain yes
	AddKeysToAgent yes
# ----------------------------

# --- 第二个账号 ---
Host account-two    # 如：gorpelnTwo
	HostName github.com
	User accountTwo-name  # 如：gorpelnTwo
	PreferredAuthentications publickey
	IdentityFile ~/.ssh/id_rsa_two
	UseKeychain yes
	AddKeysToAgent yes
# ----------------------------
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;步骤三添加-ssh-key-及-测试&quot;&gt;步骤三：添加 SSH key 及 测试&lt;/h3&gt;
&lt;p&gt;分别登陆两个 github 账号，在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Settings&lt;/code&gt; —&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSH and GPG keys&lt;/code&gt; 中，点击 “new SSH key”，把 “id_rsa.one.pub” 和 “id_rsa.two.pub”这两个公钥的内容分别添加到相应的账号中。
为了确认我们可以通过 SSH 连接 github，可通过输入下面命令来验证&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 验证账号一
ssh -T git@gorpeln 
# 验证账号二
ssh -T git@gorpelnTwo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果看到下面信息，就说明连接正常。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hi gorpeln! You&apos;ve successfully authenticated, but GitHub does not provide shell access.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;步骤四用户名和邮箱配置&quot;&gt;步骤四：用户名和邮箱配置&lt;/h3&gt;
&lt;p&gt;在第二步创建配置文件 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;config&lt;/code&gt;时，可以直接将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;account-one&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;account-name&lt;/code&gt;设置为你的主账号（账号一）名字，如我的GitHub账户名为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gorpeln&lt;/code&gt;，你可以了通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;https://github.com/gorpeln&lt;/code&gt;访问到我，则直接将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;account-one&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;account-name&lt;/code&gt;设置为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gorpeln&lt;/code&gt;，则对于使用主账号（账号一）操作的git仓库，正常&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git pull&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git push&lt;/code&gt;即可，不需要其他额外的操作。全局的用户名和邮箱可以直接配置为主账号（账号一）。&lt;/p&gt;

&lt;p&gt;对于次账号（账号二）管理的项目则需要单独配置相应的账号和邮箱。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 设置局部 用户名/邮箱 配置
git config user.name &quot;xxxx&quot;
git config user.email &quot;xxxx@xx.com&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;步骤五使用-git&quot;&gt;步骤五：使用 git&lt;/h3&gt;
&lt;p&gt;git 的使用一般是从其他仓库直接 clone 或本地新建，注意配置用户名和邮箱。&lt;/p&gt;

&lt;p&gt;如果你步骤四：用户名和邮箱配置为主账号（账号一），那么该账号操作和配置第二个账号前的操作完全相同，没有任何变化，正常操作即可。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 远程仓库地址为：git@github.com:gorpeln/repo.git
git clone git@github.com:gorpeln/repo.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;次账号（账号二 ）操作项目&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 远程仓库地址为：git@github.com:gorpeln-two/repo.git
git clone git@gorpelnTwo:gorpeln-two/repo.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果你使用第三方图形工具操作，如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sourcetree&lt;/code&gt;,进行操作时，记得不要忘了&lt;strong&gt;远程仓库地址&lt;/strong&gt;的修改。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>用 Substats 和 Shields.io 为你的个人主页定制动态数据小牌子</title>
        <link>https://gorpeln.top/article/16874238349</link>
        <guid isPermaLink="true">https://gorpeln.top/article/16874238349</guid>
        <pubDate>2023-06-22</pubDate>
        <description>&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.top/blog/20230622165034171.jpg!gorpeln&quot; alt=&quot;20230622165034171&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果你浏览过一些 GitHub 的开源项目，你一定见过很多 README 文档中都会出现的五颜六色、各式各样的「小牌子」。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.top/blog/20230622165034172.png!gorpeln&quot; alt=&quot;20230622165034172&quot; /&gt;
最初，这些「小牌子」的主要作用是为了显示「某个 GitHub 项目」的「某种状态」，比如项目的编译是否成功、文档是否更新至最新、软件的下载数量有多少……不过，从原理的角度来说，这些「小牌子」都是通过我们给「牌子渲染服务器」提供一些数据后，服务器返回给我们一个 SVG 格式的图片来工作的。我们将返回的 SVG 图片嵌入到 GitHub 的 README 文档或其他网页里面，就完成了一个「小牌子」的制作。&lt;/p&gt;

&lt;p&gt;因此，我们不仅可以将这些「小牌子」用在 GitHub 里，如果你拥有自己的「个人主页」、「博客」或其他展示个人资料的地方，只要你可以控制网页的 HTML，能自己向其中插入一些自定义代码，你就可以借助于「小牌子服务器」来自制一些好看又能实时更新的「个人资料展示牌」、「订阅地址标识牌」等等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.top/blog/20230622165034173.png!gorpeln&quot; alt=&quot;20230622165034173&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;shieldsio-的基本用法&quot;&gt;Shields.io 的基本用法&lt;/h3&gt;

&lt;h4 id=&quot;简单定制静态小牌子&quot;&gt;简单定制静态小牌子&lt;/h4&gt;
&lt;p&gt;Shields.io 就是一个我们开头提到的「牌子渲染服务」。事实上，GitHub 上面大部分「小牌子」都是用 Shields.io 来渲染的。我们可以借助于 Shields.io 服务定制一些个性化的「小牌子」。一个最简单的例子就是：&lt;a href=&quot;https://img.shields.io/badge/%E9%A3%8E%E6%9C%AA%E6%AD%A2-gorpeln-da282a&quot;&gt;https://img.shields.io/badge/风未止-gorpeln-da282a&lt;/a&gt;，这一请求可以渲染得到如下效果的小牌子。&lt;/p&gt;

&lt;p&gt;可以发现，简单定制小牌子非常方便，最最基础的语法规则就是：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.top/blog/20230622165034174.png!gorpeln&quot; alt=&quot;20230622165034174&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://img.shields.io/badge/{左半部分标签}-{右半部分标签}-{右半部分颜色}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;另外，在 Shields.io 的官网上面有非常方便的「小牌子生成器」，我们可以直接用它来构造一个「小牌子」，只需要按照下图的样子：填入左半边标签、填入右半边标签，再定义右半边的颜色，点击 Make Badge 即可生成。其中，右半边的颜色我们可以用官方提供的几种预设颜色名称（下方 Colors）或者我们自己提供十六进制颜色代码都可以。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.top/blog/20230622165034175.png!gorpeln&quot; alt=&quot;20230622165034175&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们按照上面的方法构造一个链接，就制作完成我们的小牌子啦！这样得到的链接是一个 SVG 图片链接，我们可以直接用插入图片的语法规则加到我们的 Markdown 文本文件中或 HTML 里面。&lt;/p&gt;

&lt;h4 id=&quot;动态实时更新的小牌子&quot;&gt;动态实时更新的小牌子&lt;/h4&gt;
&lt;p&gt;事实上，我们前面生成的小牌子都是静态的小牌子：其中的文本内容是固定不变的，仅能用于做一个好看的标识。而事实上，Shields.io 生成的小牌子完全支持动态数据显示，比如粉丝、关注者数量、RSS 订阅者数量……&lt;/p&gt;

&lt;p&gt;如果我们想要显示一些动态变化的数据，那么我们就需要一个受支持的数据接口，这样我们的「Shields.io 小牌子生成服务器」就会先行从这一数据接口请求相应的动态数据，并按照请求的结果将数据渲染成不同的「小牌子」。（具体的语法请继续向下阅读）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.top/blog/20230622165034176.png!gorpeln&quot; alt=&quot;20230622165034176&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但是，虽然 Shields.io 服务 API 的功能非常完善，能够支持许多第三方 API 节点的数据服务，但是有一些服务：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;API 接口返回复杂，无法直接用 Shields.io 简单处理&lt;/li&gt;
  &lt;li&gt;API 访问缓慢、不稳定，经常出现超时或无法访问的情况&lt;/li&gt;
  &lt;li&gt;访问一些数据需要进行认证，直接访问会返回 403 无权限&lt;/li&gt;
  &lt;li&gt;直接不对外公开 API 接口，没有面向开发者的开放平台，无法直接请求数据&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当我们想要显示这些平台的关注者数量、粉丝数量时，往往就力不从心了。因此，我使用 Serverless 技术实现了「Substats: Subscriber Statistics」—— 一个专注提供多个服务、平台、网站的粉丝、关注、订阅数量的 API 中转站，用来专门处理这些单靠 Shields.io 不方便直接处理的疑难杂症。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Substats 项目开源在：GitHub - &lt;a href=&quot;https://github.com/spencerwooo/Substats&quot;&gt;spencerwooo/Substats&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Substats 的 API 地址位于：Home - &lt;a href=&quot;https://api.spencerwoo.com/substats/&quot;&gt;Substats API&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;另外，关于如何调用 Substats API，我还撰写了比较详细的文档：&lt;a href=&quot;https://substats.spencerwoo.com/&quot;&gt;Substats Documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面我来简单介绍一下如何利用 Substats 配合 Shields.io 定制小牌子 ( •̀ ω •́ )✧&lt;/p&gt;

&lt;h3 id=&quot;用-substats-配合-shieldsio-制作动态小牌子&quot;&gt;用 Substats 配合 Shields.io 制作动态小牌子&lt;/h3&gt;

&lt;h4 id=&quot;通过-substats-api-获取我们期望的数据&quot;&gt;通过 Substats API 获取我们期望的数据&lt;/h4&gt;

&lt;p&gt;为了更好的配合 Shields.io 服务，我特意将 Substats 的 API 设计成简单拼接 URL 即可进行数据请求。Substats API 的语法非常简单，我们只需要关注并提供如下的两个字段即可进行请求：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;目标服务名称 source：你所想要请求的服务、网站和平台名（比如：gorpeln、weibo……）&lt;/li&gt;
  &lt;li&gt;请求数据标签 queryKey：在这一服务中查询的关注数据对应的标签或名称（比如我的用户名 gorpeln）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样，我们就可以用这样的语法来拼接一个 URL（注意第一个字符是 ?，其他用 &amp;amp; 拼接）：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://api.spencerwoo.com/substats/?source={目标服务名称}&amp;amp;queryKey={请求数据标签}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;利用这样的语法，我们就可以进行数据请求啦。继续上面图示中的例子，比如我想要制作一个实时显示我自己的gorpeln的github关注数量的小牌子，我拼接成的 URL 即为：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://api.spencerwoo.com/substats/?source=github&amp;amp;queryKey=gorpeln
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;非常方便！这一 URL 会给我们返回类似下面的 JSON 结果：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  &quot;status&quot;: 200,
  &quot;data&quot;: {
    &quot;totalSubs&quot;: 999,
    &quot;subsInEachSource&quot;: {
      &quot;github&quot;: 999
    },
    &quot;failedSources&quot;: {}
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们可以这样理解返回的 JSON 数据：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;status&lt;/code&gt; 是请求是否成功，成功即为 200（表示 HTTP OK）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt; 就是请求返回的数据（其中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;totalSubs&lt;/code&gt; 表示总关注数量，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subsInEachSource&lt;/code&gt; 表示每个服务请求到的粉丝数据，最后 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;failedSources&lt;/code&gt; 表示请求失败的数据源。）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以看到我们所需要的字段即为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$.data.totalSubs&lt;/code&gt;，也就是 999 —— 我的github总关注人数。接下来，我们只需要告诉 Shields.io：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;我们请求的 URL 地址&lt;/li&gt;
  &lt;li&gt;返回数据中所要的字段&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这两个参数，即可成功制作一个动态小牌子。&lt;/p&gt;

&lt;h4 id=&quot;用-shieldsio-制作最终动态小牌子&quot;&gt;用 Shields.io 制作最终动态小牌子&lt;/h4&gt;

&lt;p&gt;我们继续借助 Shields.io 官网上面提供的「小牌子生成器」，这次我们稍微向下滚动，找到 Dynamic 版本「小牌子生成器」，并按照这样的规则依次操作：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;数据类型 data type 选择：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSON&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;标签 label 填入：小牌子左侧的标签，比如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;github关注&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;API 地址 data url 填入：我们刚刚的 API URL：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;https://api.spencerwoo.com/substats/?source=github&amp;amp;queryKey=gorpeln&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;请求字段 query 填入：我们 Substats API 数据中的这一字段：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$.data.totalSubs&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;标签颜色 color 填入：一个十六进制的颜色代码，比如：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;da282a&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;……（余下的两个参数：前缀 prefix 和后缀 suffix，可以根据自己的需要自行定义）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样，我们就借助 Shields.io 构造出来一个自定义的动态 SVG 小牌子（由于我们的请求中包含有 URL 中非法的字符，因此下面这个是 URL 编码之后的 SVG 小牌子地址）：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://img.shields.io/badge/dynamic/json?color=da282a&amp;amp;label=github%E5%85%B3%E6%B3%A8&amp;amp;query=%24.data.totalSubs&amp;amp;url=https%3A%2F%2Fapi.spencerwoo.com%2Fsubstats%2F%3Fsource%3Dgithub%26queryKey%3Dgorpeln
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.top/blog/20230622165034177.png!gorpeln&quot; alt=&quot;20230622165034177&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;其他-substats-api-的功能和语法规则&quot;&gt;其他 Substats API 的功能和语法规则&lt;/h3&gt;
&lt;p&gt;另外，Substats API 还可以串联多个不同的数据源和它们对应的请求参数。比如，我同时请求酷安、网易云音乐、GitHub 三个平台上面的关注，即可这样构造请求（多个 source 和 queryKey 组合按照顺序进行请求即可，顺序在请求过程中不会丢失）：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://api.spencerwoo.com/substats/?source=coolapk&amp;amp;queryKey=%E5%94%90%E7%8E%89%E5%B0%8F%E7%8B%97&amp;amp;source=neteaseMusic&amp;amp;queryKey=339332&amp;amp;source=github&amp;amp;queryKey=gorpeln
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可以看到，上面的 URL 里，我直接串联了多个 source 和 queryKey 的请求组合，同时请求。这样我们就可以得到这三个平台上面关注者数量的总和 totalSubs，以及每个平台各自的关注者数量 subsInEachSource：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  &quot;status&quot;: 200,
  &quot;data&quot;: {
    &quot;totalSubs&quot;: 1312,
    &quot;subsInEachSource&quot;: {
      &quot;coolapk&quot;: 638,
      &quot;neteaseMusic&quot;: 361,
      &quot;github&quot;: 313
    },
    &quot;failedSources&quot;: {}
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;那么，我们就可以直接用 Shields.io 构造一个如下的 SVG 小牌子：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://img.shields.io/badge/dynamic/json?color=0084ff&amp;amp;label=%E9%85%B7%E5%AE%89|%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90|GitHub&amp;amp;query=$.data.totalSubs&amp;amp;url=https://api.spencerwoo.com/substats/?source=coolapk&amp;amp;queryKey=%E5%94%90%E7%8E%89%E5%B0%8F%E7%8B%97&amp;amp;source=neteaseMusic&amp;amp;queryKey=339332&amp;amp;source=github&amp;amp;queryKey=gorpeln
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这样我们就可以直接得到三个平台总关注数量的一个「小牌子」&lt;/p&gt;

&lt;p&gt;同时，如果你想同时请求多个平台，但是平台中请求的数据标签名称是一样的，比如我们同时请求 Feedly 和 NewsBlur 两个 RSS 订阅服务里我自己的 RSS 链接 &lt;a href=&quot;https://gorpeln.top/feed.xml&quot;&gt;https://gorpeln.top/feed.xml&lt;/a&gt; 的订阅数量，那么我们可以：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;直接用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|&lt;/code&gt; 将 feedly 和 newsblur 直接连接，传递给 source 作为参数&lt;/li&gt;
  &lt;li&gt;并将 RSS 链接传递给 queryKey 作为参数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从而构造这样的请求：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://api.spencerwoo.com/substats/?source=feedly|newsblur&amp;amp;queryKey=https://gorpeln.top/feed.xml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样，我们就可以直接得到两个平台同一个 RSS 源的总订阅数量：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  &quot;status&quot;: 200,
  &quot;data&quot;: {
    &quot;totalSubs&quot;: 17,
    &quot;subsInEachSource&quot;: {
      &quot;feedly&quot;: 14,
      &quot;newsblur&quot;: 3
    },
    &quot;failedSources&quot;: {}
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从而制作表示 RSS 链接总订阅人数的「小牌子」：&lt;/p&gt;

&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;Substats 是我借助 Serverless 技术构建的一个 Cloudflare Worker，直接部署在 Cloudflare 全球 CDN 节点上，访问速度非常的快。因此，如果你使用 Substats 和 Shields.io 来制作「小牌子」，生成 SVG 所消耗的时间的占比较大的部分应该是和原服务 API 沟通的时间（比如 NewsBlur 就特别慢）。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>个人网站，零成本、低门槛创建专属数据分析工具：umami.is</title>
        <link>https://gorpeln.top/article/16829158558</link>
        <guid isPermaLink="true">https://gorpeln.top/article/16829158558</guid>
        <pubDate>2023-05-01</pubDate>
        <description>&lt;p&gt;&lt;strong&gt;Google Analytics&lt;/strong&gt; 应该是当今互联网使用最广泛的网站流量分析服务。通过在网页中嵌入追踪代码，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Google Analytics&lt;/code&gt; 能够帮我们收集网站的流量来源，同时自动分析跳出率、转化率等核心指标。但是对于大部分中小型站点而言，接入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Google Analytics&lt;/code&gt; 并不是最理想的选择，因为它太复杂了，同时国内访问也不太方便。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;umami.is&lt;/code&gt; 则可以看作是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Google Analytics&lt;/code&gt; 的精简版解决方案，它完全免费且开源，非常适合中小站点的网络流量统计分析。相对于复杂的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Google Analytics&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;umami.is&lt;/code&gt; 的界面也更加简洁，只关注于核心指标，并方便分享出去。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.top/blog/20230501123735961.png!gorpeln&quot; alt=&quot;20230501123735961&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;前期准备&quot;&gt;前期准备&lt;/h3&gt;
&lt;p&gt;你需要完成以下 3 个步骤：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;访问 &lt;a href=&quot;https://github.com/umami-software/umami&quot;&gt;umami.is 代码仓库&lt;/a&gt;，点击右上方 Fork 到自己的帐号。&lt;/li&gt;
  &lt;li&gt;访问 &lt;a href=&quot;https://vercel.com/dashboard&quot;&gt;Vercel注册&lt;/a&gt;页面，点击使用 GitHub 登录到 Vercel。&lt;/li&gt;
  &lt;li&gt;访问 &lt;a href=&quot;https://supabase.com/dashboard/projects&quot;&gt;Supabase注册&lt;/a&gt; 页面，点击使用 GitHub 登录到 Supabase。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;1在supabase创建数据库&quot;&gt;1、在Supabase创建数据库&lt;/h3&gt;
&lt;p&gt;我们需要先在 Supabase 的主界面中找到 New Project 按钮创建一个新的数据库。名字可以使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;umami&lt;/code&gt;，然后设置一个自己记得住的数据库密码（一会要用）。下方的 Region 区域选择 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Northeast Asia（Tokyo）&lt;/code&gt;东京区域。Supabase 本身使用了 AWS 云服务，东京区域在大陆地区的访问速度还是比较理想的。等待数据库建立，需要几分钟的时间。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.top/blog/20230501123735962.png!gorpeln&quot; alt=&quot;20230501123735962&quot; /&gt;&lt;/p&gt;

&lt;p&gt;建立之后，点击左下方的 Project Settings，选择 Database，找到 Connection string 中的 URL 一栏，&lt;strong&gt;复制内容，并将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[YOUR-PASSWORD]&lt;/code&gt;替换为上一步生成的密码&lt;/strong&gt;。
Supabase 平台的操作就结束了。
&lt;img src=&quot;https://img.gorpeln.top/blog/20230501123735963.png!gorpeln&quot; alt=&quot;20230501123735963&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2在-vercel-部署-umami&quot;&gt;2、在 Vercel 部署 Umami&lt;/h3&gt;
&lt;p&gt;登录&lt;a href=&quot;https://vercel.com/dashboard&quot;&gt;Vercel&lt;/a&gt; 之后，点击右上角 Add New Project，并导入事先 Fork 的项目仓库。创建项目的页面中，会自动加载你 GitHub 帐号下方的代码仓库。还记得准备步骤 Fork 的 umami.is 仓库吗？选中即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.top/blog/20230501123735964.png!gorpeln&quot; alt=&quot;20230501123735964&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在 Configure Project 中需要设置两个环境变量（&lt;strong&gt;Environment Variables&lt;/strong&gt;）。
分别添加 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DATABASE_URL&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HASH_SALT&lt;/code&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DATABASE_URL&lt;/code&gt;：是上一步在 Subabase 复制的 URL，记得替换自己的 Password；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HASH_SALT&lt;/code&gt;：它的值可以是任意随机英文字符串，比如我使用了我的用户名 HUHUHANG，你也可以自定义其他随机字符串&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最后点击 Deploy，等待两分钟。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.top/blog/20230501123735965.png!gorpeln&quot; alt=&quot;20230501123735965&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3测试和设置&quot;&gt;3、测试和设置&lt;/h3&gt;
&lt;p&gt;至此，主要步骤已经顺利完成，你需要做的只是耐心等待项目部署完毕。完成之后，Vercel 会自动跳转到项目主页，并随机分配一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;域名&lt;/code&gt;（需要科学上网，可以绑定自己的域名）。点击 &lt;strong&gt;Visit&lt;/strong&gt; 访问项目，umami 默认的后台登录的用户名是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;admin&lt;/code&gt;，密码是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;umami&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;1自定义域名&quot;&gt;1）自定义域名&lt;/h4&gt;
&lt;p&gt;首先是设置一个独立域名，当然前提条件是你有自己的域名，没有的话可以到任意域名服务商（阿里云、腾讯云等）购买。当然你也可以一直使用 Vercel 自动分配的域名（Vercel 自动分配的域名需要科学上网）。&lt;/p&gt;

&lt;h4 id=&quot;2重设-umami-密码并绑定站点&quot;&gt;2）重设 umami 密码并绑定站点&lt;/h4&gt;
&lt;p&gt;不要忘记到 umami 后台重设默认的管理员密码。同时，你可以新建站点并获取到数据追踪代码嵌入到你的站点中。
&lt;img src=&quot;https://img.gorpeln.top/blog/20230501123735966.png!gorpeln&quot; alt=&quot;20230501123735966&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里非常推荐开启「&lt;strong&gt;启用共享链接&lt;/strong&gt;」的选项，这是 umami 的一大特色，可以方便分享你的站点访问数据。同时当你自己查看时，可以免登录。你可以 &lt;a href=&quot;https://umami.202090.xyz/share/oWC5HwUyPml1gkRI/gorpeln.top&quot;&gt;访问我的示例分享页面&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;：如果需要删除网站，先将语言切换至 English，中文状态无法删除。&lt;/p&gt;

&lt;h3 id=&quot;4常见问题和小结&quot;&gt;4、常见问题和小结&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Q：Vercel 和 Supabase 是免费的吗？我能用多久？&lt;/strong&gt; &lt;br /&gt;
A：目前 Vercel 的个人帐号完全免费，企业帐号才需要付费。Supabase 的免费数据库存在 500 MB 的限制，对于中小站点这个容量理论上够用很多年了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q：umami 的访问速度如何？&lt;/strong&gt;  &lt;br /&gt;
A：据我所知，Vercel 使用了 Google Cloud 的云服务，距离大陆地区最近的节点在台湾省和香港特别行政区，访问速度还算理想。而 Supabase 使用了 AWS 云服务，一开始我们创建的数据库就选择了离大陆地区最近的东京数据中心。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q：umami 后续如何升级？&lt;/strong&gt; &lt;br /&gt;
A：Vercel 的部署是自动触发和完成的，也就是说当 GitHub 代码仓库更新时，Vercel 会帮你自动部署上线最新版本的 umami。你可以不定期访问你 Fork 后的代码仓库，选中 Fetch upstream 从 umami 官方仓库同步最新的代码后即可自动升级。当然，你还可以从一开始直接部署官方仓库的代码，完全跟随官方版本迭代升级。&lt;/p&gt;

</description>
      </item>
    
  </channel>
</rss>